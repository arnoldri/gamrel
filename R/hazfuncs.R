####################################################################################
# Hazard rate functions

####################################################################################
# Plot hazard rate functions

#' Plot hazard rate function
#' 
#' @param model.list Model specification
#' @param npts Number of plotting points
#' @param use.Cpp Use C++ code?
#' @param ... Other arguments to plot()
#' 
#' @export
plot_lambdafunc <- function(model.list, npts=101, use.Cpp=TRUE, ...) {
  if(model.list$model %in% c("IFR","DFR","LWB","LCV")) {
    tvec <- seq(from=0, to=1.1*max(model.list$thetavec), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec))
    fvec <- lambda.func(tvec, model.list, use.Cpp=use.Cpp)
    plot(tvec, fvec, ylim=c(0,1.1*max(fvec)),
         xlab="t", ylab=expression(lambda(t)), main=model.list$model, ...)
  } else if(model.list$model%in%c("SBT","MBT")) {
    tvec <- seq(from=0, to=1.1*max(c(model.list$thetavec1,model.list$thetavec2)), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec1,model.list$thetavec2))
    fvec <- lambda.func(tvec, model.list, use.Cpp=use.Cpp)
    plot(tvec, fvec, ylim=c(0,1.1*max(fvec)),
         xlab="t", ylab=expression(lambda(t)), main=model.list$model, ...)
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
  invisible()
}

# Evaluate Hazard rate functions

#' Hazard rate function 
#' 
#' @param tvec Locations at which to evaluate the function
#' @param model.list Model specification
#' @param use.Cpp Use cpp to evaluate the function?
#' 
#' @description Hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' @export
lambda.func <- function(tvec, model.list, use.Cpp=TRUE) {
  if(model.list$model=="IFR") {
    return(lambda.func.ifr(tvec, model.list$lambda0, model.list$thetavec, model.list$wvec,  
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="DFR") {
    return(lambda.func.dfr(tvec, model.list$lambda0, model.list$thetavec, model.list$wvec,  
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="LWB") {
    return(lambda.func.lwb(tvec, model.list$lambda0, model.list$a, 
                           model.list$thetavec, model.list$wvec, 
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="SBT") {
    return(lambda.func.sbt(tvec,
                           model.list$lambda0, 
                           model.list$thetavec1, model.list$wvec1, 
                           model.list$thetavec2, model.list$wvec2, 
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="MBT") {
    return(lambda.func.mbt(tvec,
                           model.list$pival, 
                           model.list$lambda01, model.list$thetavec1, model.list$wvec1, 
                           model.list$lambda02, model.list$thetavec2, model.list$wvec2, 
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="LCV") {
    return(lambda.func.lcv(tvec, 
                           model.list$lambda0, model.list$w0,
                           model.list$thetavec, model.list$wvec, 
                           use.Cpp=use.Cpp))
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
}

#' Hazard rate function - IFR case
#' 
#' @param tvec Locations at which to evaluate the function
#' @param lambda0 Offset to be added to the hazard rate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param use.Cpp Use C++ function?
#' 
#' @export
lambda.func.ifr <- function(tvec, lambda0, thetavec, wvec, use.Cpp=TRUE) {
  # hazard rate function - IFR case
  if(use.Cpp) {
    return(lambda_func_ifr_c(tvec, lambda0, thetavec, wvec))
  }
  lambda.vec <- as.vector(outer(tvec, thetavec, function(t,theta) theta<=t)%*%wvec)
  lambda.vec <- lambda.vec + lambda0
  
  return(lambda.vec)
}

#' @export
lambda.func.dfr <- function(tvec, lambda0, thetavec, wvec, use.Cpp=TRUE) {
  # hazard rate function
  if(use.Cpp) {
    return(lambda_func_dfr_c(tvec, lambda0, thetavec, wvec))
  }
  lambda.vec <- as.vector(outer(tvec, thetavec, function(t,theta) theta>t)%*%wvec)
  lambda.vec <- lambda.vec + lambda0
  
  return(lambda.vec)
}

#' @export
lambda.func.lwb <- function(tvec, lambda0, a, thetavec, wvec, use.Cpp=TRUE) {
  # hazard rate function - Lo+Weng Bathtub
  if(use.Cpp) {
    return(lambda_func_lwb_c(tvec, lambda0, a, thetavec, wvec))
  }
  lambda.vec <- as.vector(outer(tvec, thetavec, function(t,theta) theta<abs(t-a))%*%wvec)
  lambda.vec <- lambda.vec + lambda0
  
  return(lambda.vec)
}

#' @export
lambda.func.sbt <- function(tvec, lambda0, thetavec1, wvec1, thetavec2, wvec2, 
                            use.Cpp=TRUE) {
  # hazard rate function - Superposition Bathtub
  lambda.vec <- ( lambda0 
                  + lambda.func.dfr(tvec, 0, thetavec1, wvec1, use.Cpp=use.Cpp)
                  + lambda.func.ifr(tvec, 0, thetavec2, wvec2, use.Cpp=use.Cpp) )
  return(lambda.vec)
}

#' @export
lambda.func.mbt <- function(tvec, pival, lambda01, thetavec1, wvec1, 
                            lambda02, thetavec2, wvec2, use.Cpp=TRUE) {
  # hazard rate function - Mixture Bathtub
  h1vec <- lambda.func.dfr(tvec, lambda01, thetavec1, wvec1, use.Cpp=use.Cpp)
  h2vec <- lambda.func.ifr(tvec, lambda02, thetavec2, wvec2, use.Cpp=use.Cpp)
  ih1vec <- int.lambda.func.dfr(tvec, lambda01, thetavec1, wvec1, use.Cpp=use.Cpp)
  ih2vec <- int.lambda.func.ifr(tvec, lambda02, thetavec2, wvec2, use.Cpp=use.Cpp)
  fs1vec <- exp(-ih1vec)
  fs2vec <- exp(-ih2vec)
  lambda.vec <- (pival*h1vec*fs1vec + (1-pival)*h2vec*fs2vec)/(pival*fs1vec+(1-pival)*fs2vec)
  return(lambda.vec)
}

#' @export
lambda.func.lcv <- function(tvec, lambda0, w0, thetavec, wvec, use.Cpp=TRUE) {
  # hazard rate function - Log Convex
  lambda.vec <- lambda0*exp(int.lambda.func.ifr(tvec, w0, thetavec, wvec, use.Cpp=use.Cpp))
  return(lambda.vec)
}

#' Plot integrated hazard rate function
#' 
#' @param model.list Model specification
#' @param npts Number of plotting points
#' @param use.Cpp Use C++ code?
#' @param ... Other arguments to plot()
#' 
#' @export
plot_intlambdafunc <- function(model.list, npts=101, use.Cpp=TRUE, ...) {
  if(model.list$model %in% c("IFR","DFR","LWB","LCV")) {
    tvec <- seq(from=0, to=1.1*max(model.list$thetavec), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec))
    fvec <- int.lambda.func(tvec, model.list, use.Cpp=use.Cpp)
    plot(tvec, fvec, ylim=c(0,1.1*max(fvec)),
         xlab="t", ylab=expression(Lambda(t)), main=model.list$model, ...)
  } else if(model.list$model%in%c("SBT","MBT")) {
    tvec <- seq(from=0, to=1.1*max(c(model.list$thetavec1,model.list$thetavec2)), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec1,model.list$thetavec2))
    fvec <- int.lambda.func(tvec, model.list, use.Cpp=use.Cpp)
    plot(tvec, fvec, ylim=c(0,1.1*max(fvec)),
         xlab="t", ylab=expression(Lambda(t)), main=model.list$model, ...)
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
  invisible()
}

#' Integrated hazard rate function 
#' 
#' @param tvec Locations at which to evaluate the function
#' @param model.list Model specification
#' @param use.Cpp Use cpp to evaluate the function?
#' 
#' @description Hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' @export
int.lambda.func <- function(tvec, model.list, use.Cpp=TRUE) {
  if(model.list$model=="IFR") {
    return(int.lambda.func.ifr(tvec, model.list$lambda0, model.list$thetavec, model.list$wvec, use.Cpp=use.Cpp))
  } else if(model.list$model=="DFR") {
    return(int.lambda.func.dfr(tvec, model.list$lambda0, model.list$thetavec, model.list$wvec, use.Cpp=use.Cpp))
  } else if(model.list$model=="LWB") {
    return(int.lambda.func.lwb(tvec, model.list$lambda0, model.list$a, model.list$thetavec, model.list$wvec, use.Cpp=use.Cpp))
  } else if(model.list$model=="SBT") {
    return(int.lambda.func.sbt(tvec, 
                               model.list$lambda0, 
                               model.list$thetavec1, model.list$wvec1, 
                               model.list$thetavec2, model.list$wvec2, 
                               use.Cpp=use.Cpp))
  } else if(model.list$model=="MBT") {
    return(int.lambda.func.mbt(tvec, 
                               model.list$pival, 
                               model.list$lambda01, model.list$thetavec1, model.list$wvec1, 
                               model.list$lambda02, model.list$thetavec2, model.list$wvec2, 
                               use.Cpp=use.Cpp))
  } else if(model.list$model=="LCV") {
    return(int.lambda.func.lcv(tvec, 
                               model.list$lambda0, model.list$w0, 
                               model.list$thetavec, model.list$wvec, 
                               use.Cpp=use.Cpp))
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
}

#' Integrated hazard rate function - IFR case
#' 
#' @param tvec Locations at which to evaluate the function
#' @param lambda0 Offset to be added to the hazard rate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param use.Cpp Use cpp to evaluate the function?
#' 
#' @description Integrated hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' @export
int.lambda.func.ifr <- function(tvec, lambda0, thetavec, wvec, use.Cpp=TRUE) {
  # integrated hazard rate function - IFR case
  if(use.Cpp) {
    return(int_lambda_func_ifr_c(tvec, lambda0, thetavec, wvec))
  }
  int.lambda.vec <- as.vector(outer(tvec, thetavec, 
                                    function(t,theta) pmax(0,t-theta))%*%wvec)
  int.lambda.vec <- int.lambda.vec + lambda0*tvec
  
  return(int.lambda.vec)
}

#' Integrated hazard rate function - DFR case
#' 
#' @param tvec Locations at which to evaluate the function
#' @param lambda0 Offset to be added to the hazard rate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param use.Cpp Use cpp to evaluate the function?
#' 
#' @description Integrated hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' @export
int.lambda.func.dfr <- function(tvec, lambda0, thetavec, wvec, use.Cpp=TRUE) {
  # integrated hazard rate function - DFR case
  if(use.Cpp) {
    return(int_lambda_func_dfr_c(tvec, lambda0, thetavec, wvec))
  }
  int.lambda.vec <- as.vector(outer(tvec, thetavec, 
                                    function(t,theta) pmin(t,theta))%*%wvec)
  int.lambda.vec <- int.lambda.vec + lambda0*tvec
  
  return(int.lambda.vec)
}

#' @export
int.lambda.func.lwb <- function(tvec, lambda0, a, thetavec, wvec, use.Cpp=TRUE) {
  # integrated hazard rate function - Lo-Weng Bathtub
  if(use.Cpp) {
    return(int_lambda_func_lwb_c(tvec, lambda0, a, thetavec, wvec))
  }
  int.lambda.vec <- as.vector(outer(tvec, thetavec, 
                                    function(t,theta) {
                                      ifelse(t<=a, (theta<a)*pmin(t,a-theta),
                                             pmax(0,a-theta)+pmax(0,t-a-theta))
                                    })%*%wvec)
  return(int.lambda.vec)
}

#' @export
int.lambda.func.sbt <- function(tvec, lambda0, thetavec1, wvec1, thetavec2, wvec2, use.Cpp=TRUE) {
  # integrated hazard rate function - Superposition Bathtub
  int.lambda.vec <- ( lambda0*tvec 
                      + int.lambda.func.dfr(tvec, 0, thetavec1, wvec1, use.Cpp=use.Cpp)
                      + int.lambda.func.ifr(tvec, 0, thetavec2, wvec2, use.Cpp=use.Cpp) )
  return(int.lambda.vec)
}

#' @export
int.lambda.func.mbt <- function(tvec, pival, 
                                lambda01, thetavec1, wvec1, 
                                lambda02, thetavec2, wvec2, use.Cpp=TRUE) {
  # integrated hazard rate function - Mixture Bathtub
  ih1vec <- int.lambda.func.dfr(tvec, lambda01, thetavec1, wvec1, use.Cpp=use.Cpp)
  ih2vec <- int.lambda.func.ifr(tvec, lambda02, thetavec2, wvec1, use.Cpp=use.Cpp)
  fs1vec <- exp(-ih1vec)
  fs2vec <- exp(-ih2vec)
  int.lambda.vec <- -log(pival*fs1vec+(1-pival)*fs2vec)
  return(int.lambda.vec)
}

#' @export
int.lambda.func.lcv <- function(tvec, lambda0, w0, thetavec, wvec, use.Cpp=TRUE) {
  # integrated hazard rate function - Log Convex
  
  if(use.Cpp) {
    return(int_lambda_func_lcv_c(tvec, lambda0, w0, thetavec, wvec))
  }
  odx <- order(thetavec) 
  othetavec <- thetavec[odx]  # theta*_k (1...K)
  owvec <- wvec[odx]          # w*_k     (1...K)
  kmax <- length(othetavec)   # K
  othetavec <- c(0,othetavec,1.1*othetavec[kmax]) # 0, thetavec, 1.1*last
  owvec <- c(0,owvec,0)                           # 0, wvec,     0
  kmaxp2 <- kmax+2            # K+2
  k1vec <- apply(outer(tvec, othetavec, function(t,theta) theta<=t),1,sum)
  k1vec <- pmin(pmax(1,k1vec),kmaxp2-1)
  
  s1vec <- cumsum(owvec)
  s01vec <- w0 + s1vec
  s2vec <- cumsum(owvec*othetavec)
  ccvec <- lambda0*exp(-s2vec)/s01vec
  ccvec1 <- ccvec[-kmaxp2]
  s01vec1 <- s01vec[-kmaxp2]
  csvec1 <- ccvec1*(exp(s01vec1*othetavec[-1])-exp(s01vec1*othetavec[-kmaxp2]))
  csvec1 <- ifelse(s01vec==0, 
                   lambda0*exp(-s2vec)*(othetavec[-1]-othetavec[-kmaxp2]), 
                   csvec1)
  ssvec <- c(0,cumsum(csvec1))
  
  ctvec <- ifelse(s01vec1[k1vec]==0,
                  lambda0*exp(-s2vec[k1vec])*(tvec-othetavec[k1vec]),
                  ccvec[k1vec]*( exp(s01vec[k1vec]*tvec)
                                -exp(s01vec[k1vec]*othetavec[k1vec])))
  
  int.lambda.vec <- ( ssvec[k1vec] + ctvec )
  
  return(int.lambda.vec)
}



#' Evaluate both the hazard and integrated hazard functions at the same locations
#' 
#' @param tvec Locations at which to evaluate the functions
#' @param model.list Model specification
#' @param use.Cpp Use cpp to evaluate the functions?
#' 
#' @description Hazard rate and Integrated hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' @export
both.lambda.funcs <- function(tvec, model.list, use.Cpp=TRUE) {
  lambda.vec <- lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
  int.lambda.vec <- int.lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
  return(list(lambda.vec=lambda.vec,int.lambda.vec=int.lambda.vec))
}

#' Plot probability density function
#' 
#' @param model.list Model specification
#' @param npts Number of plotting points
#' @param use.Cpp Use C++ code?
#' @param ... Other arguments to plot()
#' 
#' @export
plot_densityfunc <- function(model.list, npts=101, use.Cpp=TRUE, ...) {
  if(model.list$model %in% c("IFR","DFR","LWB","LCV")) {
    tvec <- seq(from=0, to=1.1*max(model.list$thetavec), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec))
  } else if(model.list$model%in%c("SBT","MBT")) {
    tvec <- seq(from=0, to=1.1*max(c(model.list$thetavec1,model.list$thetavec2)), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec1,model.list$thetavec2))
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
  lambda.vec <- lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
  int.lambda.vec <- int.lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
  fvec <- lambda.vec*exp(-int.lambda.vec)
  plot(tvec, fvec, ylim=c(0,1.1*max(fvec)),
       xlab="t", ylab=expression(f(t)), main=model.list$model, ...)
  invisible()
}

#' Plot survival function
#' 
#' @param model.list Model specification
#' @param npts Number of plotting points
#' @param use.Cpp Use C++ code?
#' @param ... Other arguments to plot()
#' 
#' @export
plot_survivalfunc <- function(model.list, npts=101, use.Cpp=TRUE, ...) {
  if(model.list$model %in% c("IFR","DFR","LWB","LCV")) {
    tvec <- seq(from=0, to=1.1*max(model.list$thetavec), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec))
  } else if(model.list$model%in%c("SBT","MBT")) {
    tvec <- seq(from=0, to=1.1*max(c(model.list$thetavec1,model.list$thetavec2)), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec1,model.list$thetavec2))
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
  int.lambda.vec <- int.lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
  fvec <- exp(-int.lambda.vec)
  plot(tvec, fvec, ylim=c(0,1.1*max(fvec)),
       xlab="t", ylab=expression(bar(F)(t)), main=model.list$model, ...)
  invisible()
}



################################################################################
#' Simulate from a hazard rate function 
#' 
#' @param n Number of failure times to simulate
#' @param model.list Model specification list
#' @param model Label of the model - see Details
#' 
#' @description Simulate from a hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' The \code{model} label can be one of 
#' IFR (increasing failure rate),
#' DFR (decreasing failure rate),
#' LWB (Lo Weng Bathtub),
#' SBT (Superposition Bathtub),
#' MBT (Mixture Bathtub), 
#' or
#' LCV (Log Convex Bathtub)
#' 
#' @export
rfail <- function(n, model.list, tau=Inf) {
  # simulate failure times, given a set of weights and locations
  # of the underlying process, and a simulation model
  # Censor at time tau
  if(model.list$model=="IFR") {
    tvec <- rfail.ifr(n, model.list$lambda0, model.list$thetavec, model.list$wvec)
  } else if(model.list$model=="DFR") {
    tvec <- rfail.dfr(n, model.list$lambda0, model.list$thetavec, model.list$wvec)
  } else if(model.list$model=="LWB") {
    tvec <- rfail.gen(n, model.list)
  } else if(model.list$model=="SBT") {
    tvec <- rfail.gen(n, model.list)
  } else if(model.list$model=="MBT") {
    tvec <- rfail.mbt(n, model.list$pival,
                      model.list$lambda01, model.list$thetavec1, model.list$wvec1, 
                      model.list$lambda02, model.list$thetavec2, model.list$wvec2)
  } else if(model.list$model=="LCV") {
    tvec <- rfail.lcv(n,  
                      model.list$lambda0, model.list$w0,
                      model.list$thetavec, model.list$wvec)
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
  tvec <- pmin(tvec, tau)
  return(tvec)
}

#' @export
rfail.gen <- function(n, model.list) {
  # Generate failure times where the integrated hazard is piecewise linear
  if(model.list$model%in%c("IFR","DFR","LWB","SBT")) {
    # Integrated hazard is piecewise linear
    if(model.list$model %in% c("IFR","DFR")) {
      tknot <- sort(unique(model.list$thetavec))
    } else if(model.list$model=="LWB") {
      tknot <- sort(unique(c(model.list$thetavec, 
                             model.list$a,
                             model.list$a+model.list$thetavec,
                             model.list$a-model.list$thetavec)))
      tknot <- tknot[tknot>=0]
    } else if(model.list$model=="SBT") {
      tknot <- sort(unique(c(model.list$thetavec1, model.list$thetavec2)))
    } else {
      stop(paste0("Model ",model.list$model," not implemented"))
    }
    kmax <- length(tknot)
    kmaxp2 <- kmax+2
    tknot <- c(0,tknot,1.1*tknot[kmax])
    svec <- int.lambda.func(tknot, model.list)
    nluvec <- -log(runif(n,0,1))
    k1vec <- apply(outer(nluvec, svec, function(nlu,s) nlu>=s),1,sum)
    k1vec <- pmin(k1vec,kmaxp2-1)
    mvec <- diff(tknot)/diff(svec)
    tvec <- tknot[k1vec] + mvec[k1vec]*(nluvec-svec[k1vec])
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
  
  # check 
  #int.lambda.vec <- int.lambda.func(tvec, model.list)
  #cat("!!*gen*"); print(range(nluvec-int.lambda.vec))
  
  return(tvec)
}

#' Simulate from an IFR model
#' 
#' @param n Number of failure times to simulate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param lambda0 Offset to be added to the hazard rate
#' 
#' @export
rfail.ifr <- function(n, lambda0, thetavec, wvec) {
  # simulate failure times from an IFR model, 
  # given a set of weights and locations
  odx <- order(thetavec)
  othetavec <- thetavec[odx]
  owvec <- wvec[odx]
  kmax <- length(othetavec)
  othetavec <- c(0,othetavec,1.1*othetavec[kmax])
  owvec <- c(0,owvec,0)
  kmaxp2 <- kmax+2
  nluvec <- -log(runif(n,0,1))
  
  s1vec <- cumsum(owvec)
  s2vec <- cumsum(owvec*othetavec)
  svec <- (lambda0+s1vec)*othetavec - s2vec
  k1vec <- apply(outer(nluvec, svec, function(nlu,s) nlu>=s),1,sum)
  k1vec <- pmin(k1vec,kmaxp2-1)
  tvec <- (nluvec + s2vec[k1vec])/(lambda0 + s1vec[k1vec])
  
  # check 
  #int.lambda.vec <- int.lambda.func.ifr(tvec, lambda0, thetavec, wvec)
  #cat("!!"); print(range(nluvec-int.lambda.vec))
  #all( tvec>othetavec[kmaxp2] | exp(-int.lambda.vec[k2vec+1])<= uvec & uvec <= exp(-int.lambda.vec[k1vec+1]) )
  #all( tvec>othetavec[kmaxp2] | (othetavec[k2vec] <= tvec & tvec <= othetavec[k2vec+1]) )
  #all( nluvec>svec[kmaxp2-1] | svec[k1vec]<= nluvec & nluvec <= svec[k2vec] )
  
  return(tvec)
}

#' Simulate from an DFR model
#' 
#' @param n Number of failure times to simulate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param lambda0 Offset to be added to the hazard rate
#' 
#' @export
rfail.dfr <- function(n, lambda0, thetavec, wvec) {
  # simulate failure times from a DFR model, 
  # given a set of weights and locations
  odx <- order(thetavec)
  othetavec <- thetavec[odx]
  owvec <- wvec[odx]
  kmax <- length(othetavec)
  othetavec <- c(0,othetavec,1.1*othetavec[kmax])
  owvec <- c(0,owvec,0)
  kmaxp2 <- kmax+2
  nluvec <- -log(runif(n,0,1))
  
  s1vec <- cumsum(owvec)
  s2vec <- cumsum(owvec*othetavec)
  s1max <- s1vec[kmaxp2] # =gamma
  s2max <- s2vec[kmaxp2]
  svec <- (lambda0+s1max-s1vec)*othetavec + s2vec
  k1vec <- apply(outer(nluvec, svec, function(nlu,s) nlu>=s),1,sum)
  k1vec <- pmin(k1vec,kmaxp2-1)
  tvec <- (nluvec-s2vec[k1vec])/(lambda0+s1max-s1vec[k1vec])
  
  # check 
  #int.lambda.vec <- int.lambda.func.dfr(tvec, lambda0, thetavec, wvec)
  #cat("!!"); print(range(nluvec-int.lambda.vec))
  #all(k2vec==kmaxp2 | svec[k1vec]<= nluvec & nluvec <= svec[k2vec])
  #int.lambda.vec <- int.lambda.func(othetavec, thetavec, wvec, lambda0, "DFR")
  #range(svec-int.lambda.vec)
  #uvec <- exp(-nluvec)
  #all(k2vec==kmaxp2 | svec[k1vec]<= nluvec & nluvec <= svec[k2vec])
  #all(k2vec==kmaxp2 | othetavec[k1vec] <= tvec & tvec <= othetavec[k2vec])
  #k2vec==kmaxp2 | othetavec[k1vec] <= tvec & tvec <= othetavec[k2vec]
  #all(k2vec==kmaxp2 | (exp(-int.lambda.vec[k2vec])<= uvec & uvec <= exp(-int.lambda.vec[k1vec])))
  return(tvec)
}

#' @export
rfail.mbt <- function(n, pival, lambda01, thetavec1, wvec1, 
                      lambda02, thetavec2, wvec2) {
  # simulate failure times from an MBT model 
  
  # Numbers selected from DFR and IFR components respectively
  n1 <- rbinom(1, n, pival)
  n2 <- n-n1
  tvec1 <- rfail.dfr(n1, 0, thetavec1, wvec1)
  tvec2 <- rfail.ifr(n2, 0, thetavec2, wvec2)
  # Combine and shuffle
  tvec <- sample(c(tvec1,tvec2))
  return(tvec)
}  

#' @export
rfail.lcv <- function(n, lambda0, w0, thetavec, wvec) {
  # simulate failure times from an LCV model
  odx <- order(thetavec) 
  othetavec <- thetavec[odx]  # theta*_k (1...K)
  owvec <- wvec[odx]          # w*_k     (1...K)
  kmax <- length(othetavec)   # K
  othetavec <- c(0,othetavec,1.1*othetavec[kmax]) # 0, thetavec, 1.1*last
  owvec <- c(0,owvec,0)                           # 0, wvec,     0
  kmaxp2 <- kmax+2            # K+2
  
  s1vec <- cumsum(owvec)
  s01vec <- w0 + s1vec
  s2vec <- cumsum(owvec*othetavec)
  ccvec <- lambda0*exp(-s2vec)/s01vec
  ccvec1 <- ccvec[-kmaxp2]
  s01vec1 <- s01vec[-kmaxp2]
  csvec1 <- ccvec1*(exp(s01vec1*othetavec[-1])-exp(s01vec1*othetavec[-kmaxp2]))
  csvec1 <- ifelse(s01vec1==0, 
                   lambda0*exp(-s2vec[-kmaxp2])*(othetavec[-1]-othetavec[-kmaxp2]), 
                   csvec1)
  ssvec <- c(0,cumsum(csvec1))
  
  nluvec <- -log(runif(n,0,1))
  k1vec <- apply(outer(nluvec, ssvec, function(nlu,ilamval) ilamval<=nlu),1,sum)
  k1vec <- pmax(1,k1vec)
  
  tvec <- ifelse(s01vec[k1vec]==0,
                 othetavec[k1vec] + (nluvec-ssvec[k1vec])/(lambda0*exp(-s2vec[k1vec])),
                 (1/s01vec[k1vec])*log(
                   exp(s01vec[k1vec]*othetavec[k1vec])
                   + (nluvec-ssvec[k1vec])/ccvec[k1vec]) 
  )
  
  # check 
  #int.lambda.vec <- int.lambda.func.lcv(tvec, lambda0, w0, thetavec, wvec)
  #cat("!!"); print(range(nluvec-int.lambda.vec))
  
  return(tvec)
}  

###############################################################################
#' Log likelihood of failure data
#' 
#' @param tvec Vector of failure times
#' @param model.list Model specification
#' @param tau Censoring time
#' @param use.Cpp Use C++ functions for speed
#' 
#' @export
llike.fail <- function(tvec, model.list, tau=Inf, use.Cpp=TRUE) {
  # log likelihood of observations tvec (censored at tau)
  n <- length(tvec)
  censored <- tvec>=tau
  n0 <- n-sum(censored)
  tvec <- pmin(tvec,tau)
  
  lambda.vec <- lambda.func(tvec, model.list, use.Cpp=use.Cpp)
  int.lambda.vec <- int.lambda.func(tvec, model.list, use.Cpp=use.Cpp)
  
  retval <- sum(log(lambda.vec[!censored])) - sum(int.lambda.vec)
  return(retval)
}
###############################################################################



