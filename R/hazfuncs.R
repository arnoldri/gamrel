####################################################################################
# Hazard rate functions

####################################################################################
# Plot hazard rate functions

#' Plot hazard rate function
#' 
#' @param model.list Model specification
#' @param npts Number of plotting points
#' @param use.Cpp Use C++ code?
#' @param ... Other arguments to plot()
#' 
#' @export
plot_lambdafunc <- function(model.list, npts=101, xlim=NULL, ylim=NULL, 
                            main=NULL, add=FALSE, use.Cpp=TRUE, ...) {
  if(model.list$model %in% c("IFR","DFR","LWB","LCV","CIR","CDR")) {
    tvec <- seq(from=0, to=1.1*max(model.list$thetavec), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec))
    fvec <- lambda.func(tvec, model.list, use.Cpp=use.Cpp)
  } else if(model.list$model%in%c("SBT","MBT","CVX")) {
    tvec <- seq(from=0, to=1.1*max(c(model.list$thetavec1,model.list$thetavec2)), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec1,model.list$thetavec2))
    fvec <- lambda.func(tvec, model.list, use.Cpp=use.Cpp)
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
  if(add) {
    lines(tvec, fvec, ...)
  } else {
    if(is.null(xlim)) xlim <- c(0,1.05*max(tvec))
    if(is.null(ylim)) ylim=c(0,1.1*max(fvec))
    if(is.null(main)) main <- model.list$model
    plot(tvec, fvec, xlim=xlim, ylim=ylim,
         xlab="t", ylab=expression(lambda(t)), main=main, ...)
  }
  invisible(cbind(tvec,fvec))
}

# Evaluate Hazard rate functions

#' Hazard rate function 
#' 
#' @param tvec Locations at which to evaluate the function
#' @param model.list Model specification
#' @param use.Cpp Use cpp to evaluate the function?
#' 
#' @description Hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' @export
lambda.func <- function(tvec, model.list, use.Cpp=TRUE) {
  if(model.list$model=="IFR") {
    return(lambda.func.ifr(tvec, model.list$lambda0, model.list$thetavec, model.list$wvec,  
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="DFR") {
    return(lambda.func.dfr(tvec, model.list$lambda0, model.list$thetavec, model.list$wvec,  
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="LWB") {
    return(lambda.func.lwb(tvec, model.list$lambda0, model.list$a, 
                           model.list$thetavec, model.list$wvec, 
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="SBT") {
    return(lambda.func.sbt(tvec,
                           model.list$lambda0, 
                           model.list$thetavec1, model.list$wvec1, 
                           model.list$thetavec2, model.list$wvec2, 
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="MBT") {
    return(lambda.func.mbt(tvec,
                           model.list$pival, 
                           model.list$lambda01, model.list$thetavec1, model.list$wvec1, 
                           model.list$lambda02, model.list$thetavec2, model.list$wvec2, 
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="LCV") {
    return(lambda.func.lcv(tvec, 
                           model.list$lambda0, model.list$w0,
                           model.list$thetavec, model.list$wvec, 
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="CIR") {
    return(lambda.func.cir(tvec, model.list$lambda0, model.list$thetavec, model.list$wvec,  
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="CDR") {
    return(lambda.func.cdr(tvec, model.list$lambda0, model.list$thetavec, model.list$wvec,  
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="CVX") {
    return(lambda.func.cvx(tvec,
                           model.list$lambda0,
                           model.list$thetavec1, model.list$wvec1, 
                           model.list$thetavec2, model.list$wvec2, 
                           use.Cpp=use.Cpp))
  } else if(model.list$model=="MEW") {
    return(lambda.func.mew(tvec, 
                           model.list$lambda, model.list$alpha,
                           model.list$theta,  model.list$gamma))
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
}

#' Hazard rate function - IFR case
#' 
#' @param tvec Locations at which to evaluate the function
#' @param lambda0 Offset to be added to the hazard rate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param use.Cpp Use C++ function?
#' 
#' @export
lambda.func.ifr <- function(tvec, lambda0, thetavec, wvec, use.Cpp=TRUE) {
  # hazard rate function - IFR case
  if(use.Cpp) {
    return(lambda_func_ifr_c(tvec, lambda0, thetavec, wvec))
  }
  lambda.vec <- as.vector(outer(tvec, thetavec, function(t,theta) theta<=t)%*%wvec)
  lambda.vec <- lambda.vec + lambda0
  
  return(lambda.vec)
}

#' @export
lambda.func.dfr <- function(tvec, lambda0, thetavec, wvec, use.Cpp=TRUE) {
  # hazard rate function
  if(use.Cpp) {
    return(lambda_func_dfr_c(tvec, lambda0, thetavec, wvec))
  }
  lambda.vec <- as.vector(outer(tvec, thetavec, function(t,theta) theta>t)%*%wvec)
  lambda.vec <- lambda.vec + lambda0
  
  return(lambda.vec)
}

#' @export
lambda.func.lwb <- function(tvec, lambda0, a, thetavec, wvec, use.Cpp=TRUE) {
  # hazard rate function - Lo+Weng Bathtub
  if(use.Cpp) {
    return(lambda_func_lwb_c(tvec, lambda0, a, thetavec, wvec))
  }
  lambda.vec <- as.vector(outer(tvec, thetavec, function(t,theta) theta<abs(t-a))%*%wvec)
  lambda.vec <- lambda.vec + lambda0
  
  return(lambda.vec)
}

#' @export
lambda.func.sbt <- function(tvec, lambda0, thetavec1, wvec1, thetavec2, wvec2, 
                            use.Cpp=TRUE) {
  # hazard rate function - Superposition Bathtub
  lambda.vec <- ( lambda0 
                  + lambda.func.dfr(tvec, 0, thetavec1, wvec1, use.Cpp=use.Cpp)
                  + lambda.func.ifr(tvec, 0, thetavec2, wvec2, use.Cpp=use.Cpp) )
  return(lambda.vec)
}

#' @export
lambda.func.mbt <- function(tvec, pival, 
                            lambda01, thetavec1, wvec1, 
                            lambda02, thetavec2, wvec2, use.Cpp=TRUE) {
  # hazard rate function - Mixture Bathtub
  h1vec <- lambda.func.dfr(tvec, lambda01, thetavec1, wvec1, use.Cpp=use.Cpp)
  h2vec <- lambda.func.ifr(tvec, lambda02, thetavec2, wvec2, use.Cpp=use.Cpp)
  ih1vec <- int.lambda.func.dfr(tvec, lambda01, thetavec1, wvec1, use.Cpp=use.Cpp)
  ih2vec <- int.lambda.func.ifr(tvec, lambda02, thetavec2, wvec2, use.Cpp=use.Cpp)
  # stabilise this calculation to avoid over/underflow
  mvec <- pmin(ih1vec,ih2vec)
  fs1vec <- exp(-(ih1vec-mvec))
  fs2vec <- exp(-(ih2vec-mvec))
  #if(min(fs1vec)==1) {
  #  lambda.vec <- h2vec  # component 1 is tiny: dominated by 2
  #} else if(min(fs2vec)==1) {
  #  lambda.vec <- h1vec  # component 2 is tiny: dominated by 1
  #} else {
  #  lambda.vec <- (pival*h1vec*fs1vec + (1-pival)*h2vec*fs2vec)/(pival*fs1vec+(1-pival)*fs2vec)
  #}
  lambda.vec <- (pival*h1vec*fs1vec + (1-pival)*h2vec*fs2vec)/(pival*fs1vec+(1-pival)*fs2vec)
  return(lambda.vec)
}

#' @export
lambda.func.lcv <- function(tvec, lambda0, w0, thetavec, wvec, use.Cpp=TRUE) {
  # hazard rate function - Log Convex
  lambda.vec <- lambda0*exp(int.lambda.func.ifr(tvec, w0, thetavec, wvec, use.Cpp=use.Cpp))
  return(lambda.vec)
}

#' @export
lambda.func.cir <- function(tvec, lambda0, thetavec, wvec, use.Cpp=TRUE) {
  if(use.Cpp) {
    return(lambda_func_cir_c(tvec, lambda0, thetavec, wvec))
  }
  lambda.vec <- as.vector(outer(tvec, thetavec, function(t,theta) pmax(0,t-theta))%*%wvec)
  lambda.vec <- lambda.vec + lambda0
  
  return(lambda.vec)
}

#' @export
lambda.func.cdr <- function(tvec, lambda0, thetavec, wvec, use.Cpp=TRUE) {
  if(use.Cpp) {
    return(lambda_func_cdr_c(tvec, lambda0, thetavec, wvec))
  }
  lambda.vec <- as.vector(outer(tvec, thetavec, function(t,theta) pmax(0,theta-t))%*%wvec)
  lambda.vec <- lambda.vec + lambda0
  
  return(lambda.vec)
}

#' @export
lambda.func.cvx <- function(tvec, lambda0, 
                            thetavec1, wvec1, 
                            thetavec2, wvec2, 
                            use.Cpp=TRUE) {
  lambda.vec <- ( lambda.func.cdr(tvec, 0, thetavec1, wvec1, use.Cpp)
                 +lambda.func.cir(tvec, lambda0, thetavec2, wvec2, use.Cpp) )
  return(lambda.vec)
}


#' @export
lambda.func.mew <- function(tvec, lambda, alpha, theta, gamma, use.Cpp=TRUE) {
  # hazard rate function - MEW
  evec <- exp((tvec/theta)^gamma)
  lambda.vec <- (gamma/theta)*(tvec/theta)^(gamma-1)*evec*(lambda + alpha*(evec-1)^(alpha-1))
  return(lambda.vec)
}

#' Plot integrated hazard rate function
#' 
#' @param model.list Model specification
#' @param npts Number of plotting points
#' @param use.Cpp Use C++ code?
#' @param ... Other arguments to plot()
#' 
#' @export
plot_intlambdafunc <- function(model.list, npts=101, xlim=NULL, ylim=NULL, 
                               add=FALSE, use.Cpp=TRUE, main=NULL, ...) {
  if(model.list$model %in% c("IFR","DFR","LWB","LCV","CIR","CDR")) {
    tvec <- seq(from=0, to=1.1*max(model.list$thetavec), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec))
    fvec <- int.lambda.func(tvec, model.list, use.Cpp=use.Cpp)
  } else if(model.list$model%in%c("SBT","MBT","CVX")) {
    tvec <- seq(from=0, to=1.1*max(c(model.list$thetavec1,model.list$thetavec2)), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec1,model.list$thetavec2))
    fvec <- int.lambda.func(tvec, model.list, use.Cpp=use.Cpp)
  } else if(model.list$model%in%c("MEW")) {
    tvec <- seq(from=0, to=1.1*model.list$theta, length=npts)
    fvec <- int.lambda.func(tvec, model.list, use.Cpp=use.Cpp)
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
  if(add) {
    lines(tvec, fvec, ...)
  } else {
    if(is.null(xlim)) xlim=c(0,1.05*max(tvec))
    if(is.null(ylim)) ylim=c(0,1.1*max(fvec))
    if(is.null(main)) main <- model.list$model
    plot(tvec, fvec, xlim=xlim, ylim=ylim,
         xlab="t", ylab=expression(Lambda(t)), main=main, ...)
  }
  invisible(tvec)
}

#' Integrated hazard rate function 
#' 
#' @param tvec Locations at which to evaluate the function
#' @param model.list Model specification
#' @param use.Cpp Use cpp to evaluate the function?
#' 
#' @description Hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' @export
int.lambda.func <- function(tvec, model.list, use.Cpp=TRUE) {
  if(model.list$model=="IFR") {
    return(int.lambda.func.ifr(tvec, model.list$lambda0, model.list$thetavec, model.list$wvec, use.Cpp=use.Cpp))
  } else if(model.list$model=="DFR") {
    return(int.lambda.func.dfr(tvec, model.list$lambda0, model.list$thetavec, model.list$wvec, use.Cpp=use.Cpp))
  } else if(model.list$model=="LWB") {
    return(int.lambda.func.lwb(tvec, model.list$lambda0, model.list$a, model.list$thetavec, model.list$wvec, use.Cpp=use.Cpp))
  } else if(model.list$model=="SBT") {
    return(int.lambda.func.sbt(tvec, 
                               model.list$lambda0, 
                               model.list$thetavec1, model.list$wvec1, 
                               model.list$thetavec2, model.list$wvec2, 
                               use.Cpp=use.Cpp))
  } else if(model.list$model=="MBT") {
    return(int.lambda.func.mbt(tvec, 
                               model.list$pival, 
                               model.list$lambda01, model.list$thetavec1, model.list$wvec1, 
                               model.list$lambda02, model.list$thetavec2, model.list$wvec2, 
                               use.Cpp=use.Cpp))
  } else if(model.list$model=="LCV") {
    return(int.lambda.func.lcv(tvec, 
                               model.list$lambda0, model.list$w0, 
                               model.list$thetavec, model.list$wvec, 
                               use.Cpp=use.Cpp))
  } else if(model.list$model=="CIR") {
    return(int.lambda.func.cir(tvec, 
                               model.list$lambda0, 
                               model.list$thetavec, model.list$wvec, 
                               use.Cpp=use.Cpp))
  } else if(model.list$model=="CDR") {
    return(int.lambda.func.cdr(tvec, 
                               model.list$lambda0, 
                               model.list$thetavec, model.list$wvec, 
                               use.Cpp=use.Cpp))
  } else if(model.list$model=="CVX") {
    return(int.lambda.func.cvx(tvec, 
                               model.list$lambda0, 
                               model.list$thetavec1, model.list$wvec1, 
                               model.list$thetavec2, model.list$wvec2, 
                               use.Cpp=use.Cpp))
  } else if(model.list$model=="MEW") {
    return(int.lambda.func.mew(tvec, 
                               model.list$lambda, model.list$alpha, 
                               model.list$theta,  model.list$gamma, 
                               use.Cpp=use.Cpp))
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
}

#' Integrated hazard rate function - IFR case
#' 
#' @param tvec Locations at which to evaluate the function
#' @param lambda0 Offset to be added to the hazard rate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param use.Cpp Use cpp to evaluate the function?
#' 
#' @description Integrated hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' @export
int.lambda.func.ifr <- function(tvec, lambda0, thetavec, wvec, use.Cpp=TRUE) {
  # integrated hazard rate function - IFR case
  if(use.Cpp) {
    return(int_lambda_func_ifr_c(tvec, lambda0, thetavec, wvec))
  }
  int.lambda.vec <- as.vector(outer(tvec, thetavec, 
                                    function(t,theta) pmax(0,t-theta))%*%wvec)
  int.lambda.vec <- int.lambda.vec + lambda0*tvec
  
  return(int.lambda.vec)
}

#' Integrated hazard rate function - DFR case
#' 
#' @param tvec Locations at which to evaluate the function
#' @param lambda0 Offset to be added to the hazard rate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param use.Cpp Use cpp to evaluate the function?
#' 
#' @description Integrated hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' @export
int.lambda.func.dfr <- function(tvec, lambda0, thetavec, wvec, use.Cpp=TRUE) {
  # integrated hazard rate function - DFR case
  if(use.Cpp) {
    return(int_lambda_func_dfr_c(tvec, lambda0, thetavec, wvec))
  }
  int.lambda.vec <- as.vector(outer(tvec, thetavec, 
                                    function(t,theta) pmin(t,theta))%*%wvec)
  int.lambda.vec <- int.lambda.vec + lambda0*tvec
  
  return(int.lambda.vec)
}

#' @export
int.lambda.func.lwb <- function(tvec, lambda0, a, thetavec, wvec, use.Cpp=TRUE) {
  # integrated hazard rate function - Lo-Weng Bathtub
  if(use.Cpp) {
    return(int_lambda_func_lwb_c(tvec, lambda0, a, thetavec, wvec))
  }
  int.lambda.vec <- as.vector(outer(tvec, thetavec, 
                                    function(t,theta) {
                                      ifelse(t<=a, (theta<a)*pmin(t,a-theta),
                                             pmax(0,a-theta)+pmax(0,t-a-theta))
                                    })%*%wvec)
  int.lambda.vec <- int.lambda.vec + lambda0*tvec
  
  return(int.lambda.vec)
}

#' @export
int.lambda.func.sbt <- function(tvec, lambda0, thetavec1, wvec1, thetavec2, wvec2, use.Cpp=TRUE) {
  # integrated hazard rate function - Superposition Bathtub
  int.lambda.vec <- ( lambda0*tvec 
                      + int.lambda.func.dfr(tvec, 0, thetavec1, wvec1, use.Cpp=use.Cpp)
                      + int.lambda.func.ifr(tvec, 0, thetavec2, wvec2, use.Cpp=use.Cpp) )
  return(int.lambda.vec)
}

#' @export
int.lambda.func.mbt <- function(tvec, pival, 
                                lambda01, thetavec1, wvec1, 
                                lambda02, thetavec2, wvec2, use.Cpp=TRUE) {
  # integrated hazard rate function - Mixture Bathtub
  ih1vec <- int.lambda.func.dfr(tvec, lambda01, thetavec1, wvec1, use.Cpp=use.Cpp)
  ih2vec <- int.lambda.func.ifr(tvec, lambda02, thetavec2, wvec2, use.Cpp=use.Cpp)
  mvec <- pmin(ih1vec,ih2vec)
  fs1vec <- exp(-(ih1vec-mvec))
  fs2vec <- exp(-(ih2vec-mvec))
  int.lambda.vec <- mvec-log(pival*fs1vec+(1-pival)*fs2vec)
  return(int.lambda.vec)
}

#' @export
int.lambda.func.lcv <- function(tvec, lambda0, w0, thetavec, wvec, 
                                use.Cpp=TRUE, epsilon=.Machine$double.neg.eps*100) {
  # integrated hazard rate function - Log Convex
  
  if(use.Cpp) {
    return(int_lambda_func_lcv_c(tvec, lambda0, w0, thetavec, wvec, epsilon))
  }
  odx <- order(thetavec) 
  othetavec <- thetavec[odx]  # theta*_k (1...K)
  owvec <- wvec[odx]          # w*_k     (1...K)
  kmax <- length(othetavec)   # K
  othetavec <- c(0,othetavec,1.1*othetavec[kmax]) # 0, thetavec, 1.1*last
  owvec <- c(0,owvec,0)                           # 0, wvec,     0
  kmaxp2 <- kmax+2            # K+2
  k1vec <- apply(outer(tvec, othetavec, function(t,theta) theta<=t),1,sum)
  k1vec <- pmin(pmax(1,k1vec),kmaxp2-1)

  s1vec <- cumsum(owvec)  # C
  s01vec <- w0 + s1vec    # C0
  s2vec <- cumsum(owvec*othetavec)    # D
  ccvec <- lambda0*exp(-s2vec)/s01vec # lambda0.exp(-D)/C0
  ccvec1 <- ccvec[-kmaxp2]
  s01vec1 <- s01vec[-kmaxp2]
  csvec1 <- ccvec1*(exp(s01vec1*othetavec[-1])-exp(s01vec1*othetavec[-kmaxp2]))
  csvec1 <- ifelse(s01vec1==0, 
                   lambda0*exp(-s2vec[-kmaxp2])*(othetavec[-1]-othetavec[-kmaxp2]), 
                   csvec1)
  ssvec <- c(0,cumsum(csvec1))
  
  ctvec <- ifelse(s01vec1[k1vec]==0,
                  lambda0*exp(-s2vec[k1vec])*(tvec-othetavec[k1vec]),
                  ccvec[k1vec]*( exp(s01vec[k1vec]*tvec)
                                -exp(s01vec[k1vec]*othetavec[k1vec])))
  
  int.lambda.vec <- ( ssvec[k1vec] + ctvec )
  
  return(int.lambda.vec)
}

#' Integrated hazard rate function - CIR case
#' 
#' @param tvec Locations at which to evaluate the function
#' @param lambda0 Offset to be added to the hazard rate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param use.Cpp Use cpp to evaluate the function?
#' 
#' @description Integrated hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' @export
int.lambda.func.cir <- function(tvec, lambda0, thetavec, wvec, use.Cpp=TRUE) {
  # integrated hazard rate function - CIR case
  if(use.Cpp) {
    return(int_lambda_func_cir_c(tvec, lambda0, thetavec, wvec))
  }
  int.lambda.vec <- as.vector(outer(tvec, thetavec, 
                                    function(t,theta) 0.5*pmax(0,t-theta)*(t-theta))%*%wvec)
  int.lambda.vec <- int.lambda.vec + lambda0*tvec
  
  return(int.lambda.vec)
}


#' Integrated hazard rate function - CDR case
#' 
#' @param tvec Locations at which to evaluate the function
#' @param lambda0 Offset to be added to the hazard rate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param use.Cpp Use cpp to evaluate the function?
#' 
#' @description Integrated hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' @export
int.lambda.func.cdr <- function(tvec, lambda0, thetavec, wvec, use.Cpp=TRUE) {
  # integrated hazard rate function - CDR case
  if(use.Cpp) {
    return(int_lambda_func_cdr_c(tvec, lambda0, thetavec, wvec))
  }
  int.lambda.vec <- as.vector(outer(tvec, thetavec, 
                                    function(t,theta) (-0.5)*pmax(0,theta-t)*(theta-t))%*%wvec)
  int.lambda.vec <- int.lambda.vec + lambda0*tvec + 0.5*sum(wvec*thetvec^2)
  
  return(int.lambda.vec)
}



#' @export
int.lambda.func.cvx <- function(tvec, lambda0, thetavec1, wvec1, thetavec2, wvec2, use.Cpp=TRUE) {
  # integrated hazard rate function - Convex Bathtub
  int.lambda.vec <- ( lambda0*tvec 
                      + int.lambda.func.cir(tvec, 0, thetavec1, wvec1, use.Cpp=use.Cpp)
                      + int.lambda.func.cdr(tvec, 0, thetavec2, wvec2, use.Cpp=use.Cpp) )
  return(int.lambda.vec)
}

#' @export
int.lambda.func.mew <- function(tvec, lambda, alpha, theta, gamma, use.Cpp=TRUE) {
  # integrated hazard rate function - MEW
  evec <- exp((tvec/theta)^gamma)
  int.lambda.vec <- lambda*(evec-1) + (evec-1)^alpha
  return(int.lambda.vec)
}


#' Evaluate both the hazard and integrated hazard functions at the same locations
#' 
#' @param tvec Locations at which to evaluate the functions
#' @param model.list Model specification
#' @param use.Cpp Use cpp to evaluate the functions?
#' 
#' @description Hazard rate and Integrated hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' @export
both.lambda.funcs <- function(tvec, model.list, use.Cpp=TRUE, epsilon=.Machine$double.neg.eps*100) {
  if(!use.Cpp) {
    lambda.vec <- lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
    int.lambda.vec <- int.lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
    retval <- cbind(lambda.vec=lambda.vec,int.lambda.vec=int.lambda.vec)
  } else if(model%in%c("IFR")) {
    retval <- both_lambda_func_ifr_c(tvec, 
                                     model.list$lambda0, 
                                     model.list$thetavec, 
                                     model.list$wvec) 
    
  } else if(model%in%c("DFR")) {
    retval <- both_lambda_func_dfr_c(tvec, 
                                     model.list$lambda0, 
                                     model.list$thetavec, 
                                     model.list$wvec) 
  } else if(model%in%c("LWB")) {
    retval <- both_lambda_func_lwb_c(tvec, 
                                     model.list$lambda0, 
                                     model.list$a,
                                     model.list$thetavec, 
                                     model.list$wvec) 
  } else if(model%in%"SBT") {
    lambda.vec <- lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
    int.lambda.vec <- int.lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
    retval <- cbind(lambda.vec=lambda.vec,int.lambda.vec=int.lambda.vec)
  } else if(model%in%"MBT") {
    lambda.vec <- lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
    int.lambda.vec <- int.lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
    retval <- cbind(lambda.vec=lambda.vec,int.lambda.vec=int.lambda.vec)
  } else if(model%in%"LCV") {
    retval <- both_lambda_func_lcv_c(tvec, 
                                     model.list$lambda0, 
                                     model.list$w0,
                                     model.list$thetavec, 
                                     model.list$wvec,
                                     epsilon) 
  } else if(model%in%c("CIR")) {
    retval <- both_lambda_func_cir_c(tvec, 
                                     model.list$lambda0, 
                                     model.list$thetavec, 
                                     model.list$wvec) 
    
  } else if(model%in%c("CDR")) {
    retval <- both_lambda_func_cdr_c(tvec, 
                                     model.list$lambda0, 
                                     model.list$thetavec, 
                                     model.list$wvec) 
  } else if(model%in%"CVX") {
    lambda.vec <- lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
    int.lambda.vec <- int.lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
    retval <- cbind(lambda.vec=lambda.vec,int.lambda.vec=int.lambda.vec)
  } else if(model%in%"MEW") {
    lambda.vec <- lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
    int.lambda.vec <- int.lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
    retval <- cbind(lambda.vec=lambda.vec,int.lambda.vec=int.lambda.vec)
  }
  return(retval)
}

#' Plot probability density function
#' 
#' @param model.list Model specification
#' @param npts Number of plotting points
#' @param use.Cpp Use C++ code?
#' @param ... Other arguments to plot()
#' 
#' @export
plot_densityfunc <- function(model.list, npts=101, 
                             main=NULL, use.Cpp=TRUE, ...) {
  if(model.list$model %in% c("IFR","DFR","LWB","LCV","CIR","CDR")) {
    tvec <- seq(from=0, to=1.1*max(model.list$thetavec), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec))
  } else if(model.list$model%in%c("SBT","MBT","CVX")) {
    tvec <- seq(from=0, to=1.1*max(c(model.list$thetavec1,model.list$thetavec2)), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec1,model.list$thetavec2))
  } else if(model.list$model %in% c("MEW")) {
    tvec <- seq(from=0, to=1.1*model.list$theta, length=npts)
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
  lambda.vec <- lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
  int.lambda.vec <- int.lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
  fvec <- lambda.vec*exp(-int.lambda.vec)
  if(is.null(main)) main <- model.list$model
  plot(tvec, fvec, ylim=c(0,1.1*max(fvec)),
       xlab="t", ylab=expression(f(t)), main=main, ...)
  invisible(tvec)
}

#' Plot survival function
#' 
#' @param model.list Model specification
#' @param npts Number of plotting points
#' @param use.Cpp Use C++ code?
#' @param ... Other arguments to plot()
#' 
#' @export
plot_survivalfunc <- function(model.list, npts=101, xlim=NULL, ylim=NULL, 
                              main=NULL, add=FALSE, use.Cpp=TRUE, ...) {
  if(model.list$model %in% c("IFR","DFR","LWB","LCV","CIR","CDR")) {
    tvec <- seq(from=0, to=1.1*max(model.list$thetavec), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec))
  } else if(model.list$model%in%c("SBT","MBT","CVX")) {
    tvec <- seq(from=0, to=1.1*max(c(model.list$thetavec1,model.list$thetavec2)), length=npts)
    tvec <- sort(c(tvec,model.list$thetavec1,model.list$thetavec2))
  } else if(model.list$model %in% c("MEW")) {
    tvec <- seq(from=0, to=1.1*model.list$theta, length=npts)
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
  int.lambda.vec <- int.lambda.func(tvec=tvec, model.list=model.list, use.Cpp=use.Cpp) 
  fvec <- exp(-int.lambda.vec)
  if(add) {
    lines(tvec, fvec, ...)
  } else {
    if(is.null(main)) main <- model.list$model
    if(is.null(xlim)) xlim <- c(0,1.05*max(tvec))
    if(is.null(ylim)) ylim <- c(0,1.1*max(fvec))
    plot(tvec, fvec, xlim=xlim, ylim=ylim,
         xlab="t", ylab=expression(bar(F)(t)), main=main, ...)
  }
  invisible(tvec)
}



################################################################################
#' Simulate from a hazard rate function 
#' 
#' @param n Number of failure times to simulate
#' @param model.list Model specification list
#' @param model Label of the model - see Details
#' 
#' @description Simulate from a hazard rate function generated by 
#' a set of discrete locations and weights and integrated
#' 
#' The \code{model} label can be one of 
#' IFR (increasing failure rate),
#' DFR (decreasing failure rate),
#' LWB (Lo Weng Bathtub),
#' SBT (Superposition Bathtub),
#' MBT (Mixture Bathtub), 
#' LCV (Log Convex Bathtub)
#' MEW (Modified Exponentiated Weibull)
#' 
#' @export
rfail <- function(n, model.list, tau=Inf) {
  # simulate failure times, given a set of weights and locations
  # of the underlying process, and a simulation model
  # Censor at time tau
  if(model.list$model=="IFR") {
    tvec <- rfail.ifr(n, model.list$lambda0, model.list$thetavec, model.list$wvec)
  } else if(model.list$model=="DFR") {
    tvec <- rfail.dfr(n, model.list$lambda0, model.list$thetavec, model.list$wvec)
  } else if(model.list$model=="LWB") {
    tvec <- rfail.gen(n, model.list)
  } else if(model.list$model=="SBT") {
    tvec <- rfail.sbt(n, model.list$lambda0, 
                         model.list$thetavec1, model.list$wvec1,
                         model.list$thetavec2, model.list$wvec2)
  } else if(model.list$model=="MBT") {
    tvec <- rfail.mbt(n, model.list$pival,
                      model.list$lambda01, model.list$thetavec1, model.list$wvec1, 
                      model.list$lambda02, model.list$thetavec2, model.list$wvec2)
  } else if(model.list$model=="LCV") {
    tvec <- rfail.lcv(n,  
                      model.list$lambda0, model.list$w0,
                      model.list$thetavec, model.list$wvec)
  } else if(model.list$model=="CIR") {
    tvec <- rfail.cir(n, model.list$lambda0, model.list$thetavec, model.list$wvec)
  } else if(model.list$model=="CDR") {
    tvec <- rfail.cdr(n, model.list$lambda0, model.list$thetavec, model.list$wvec)
  } else if(model.list$model=="CVX") {
    tvec <- rfail.cvx(n, model.list$lambda0, 
                         model.list$thetavec1, model.list$wvec1,
                         model.list$thetavec2, model.list$wvec2)
  } else if(model.list$model=="MEW") {
    tvec <- rfail.mew(n,  
                      model.list$lambda, model.list$alpha,
                      model.list$theta, model.list$gamma)
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
  tvec <- pmin(tvec, tau)
  return(tvec)
}

#' @export
rfail.gen <- function(n, model.list) {
  # Generate failure times where the integrated hazard is piecewise linear
  if(model.list$model%in%c("IFR","DFR","LWB")) {
    # Integrated hazard is piecewise linear
    if(model.list$model %in% c("IFR","DFR")) {
      tknot <- sort(unique(model.list$thetavec))
    } else if(model.list$model=="LWB") {
      tknot <- sort(unique(c(model.list$thetavec, 
                             model.list$a,
                             model.list$a+model.list$thetavec,
                             model.list$a-model.list$thetavec)))
      tknot <- tknot[tknot>=0]
    } else {
      stop(paste0("Model ",model.list$model," not implemented"))
    }
    kmax <- length(tknot)
    kmaxp2 <- kmax+2
    tknot <- c(0,tknot,1.1*tknot[kmax])
    svec <- int.lambda.func(tknot, model.list)
    nluvec <- -log(runif(n,0,1))
    k1vec <- apply(outer(nluvec, svec, function(nlu,s) nlu>=s),1,sum)
    k1vec <- pmin(k1vec,kmaxp2-1)
    mvec <- diff(tknot)/diff(svec)
    tvec <- tknot[k1vec] + mvec[k1vec]*(nluvec-svec[k1vec])
  } else {
    stop(paste0("Model ",model.list$model," not implemented"))
  }
  
  # check 
  #int.lambda.vec <- int.lambda.func(tvec, model.list)
  #cat("!!*gen*"); print(range(nluvec-int.lambda.vec))
  
  return(tvec)
}

#' Simulate from an IFR model
#' 
#' @param n Number of failure times to simulate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param lambda0 Offset to be added to the hazard rate
#' 
#' @export
rfail.ifr <- function(n, lambda0, thetavec, wvec) {
  # simulate failure times from an IFR model, 
  # given a set of weights and locations
  odx <- order(thetavec)
  othetavec <- thetavec[odx]
  owvec <- wvec[odx]
  kmax <- length(othetavec)
  othetavec <- c(0,othetavec,1.1*othetavec[kmax])
  owvec <- c(0,owvec,0)
  kmaxp2 <- kmax+2
  nluvec <- -log(runif(n,0,1))
  
  s1vec <- cumsum(owvec)
  s2vec <- cumsum(owvec*othetavec)
  svec <- (lambda0+s1vec)*othetavec - s2vec
  k1vec <- apply(outer(nluvec, svec, function(nlu,s) nlu>=s),1,sum)
  k1vec <- pmin(k1vec,kmaxp2-1)
  tvec <- (nluvec + s2vec[k1vec])/(lambda0 + s1vec[k1vec])
  
  # check 
  #int.lambda.vec <- int.lambda.func.ifr(tvec, lambda0, thetavec, wvec)
  #cat("!!"); print(range(nluvec-int.lambda.vec))
  #all( tvec>othetavec[kmaxp2] | exp(-int.lambda.vec[k2vec+1])<= uvec & uvec <= exp(-int.lambda.vec[k1vec+1]) )
  #all( tvec>othetavec[kmaxp2] | (othetavec[k2vec] <= tvec & tvec <= othetavec[k2vec+1]) )
  #all( nluvec>svec[kmaxp2-1] | svec[k1vec]<= nluvec & nluvec <= svec[k2vec] )
  
  return(tvec)
}

#' Simulate from an DFR model
#' 
#' @param n Number of failure times to simulate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param lambda0 Offset to be added to the hazard rate
#' 
#' @export
rfail.dfr <- function(n, lambda0, thetavec, wvec) {
  # simulate failure times from a DFR model, 
  # given a set of weights and locations
  odx <- order(thetavec)
  othetavec <- thetavec[odx]
  owvec <- wvec[odx]
  kmax <- length(othetavec)
  othetavec <- c(0,othetavec,1.1*othetavec[kmax])
  owvec <- c(0,owvec,0)
  kmaxp2 <- kmax+2
  nluvec <- -log(runif(n,0,1))
  
  s1vec <- cumsum(owvec)
  s2vec <- cumsum(owvec*othetavec)
  s1max <- s1vec[kmaxp2] # =gamma
  s2max <- s2vec[kmaxp2]
  svec <- (lambda0+s1max-s1vec)*othetavec + s2vec
  k1vec <- apply(outer(nluvec, svec, function(nlu,s) nlu>=s),1,sum)
  k1vec <- pmin(k1vec,kmaxp2-1)
  tvec <- (nluvec-s2vec[k1vec])/(lambda0+s1max-s1vec[k1vec])
  
  # check 
  #int.lambda.vec <- int.lambda.func.dfr(tvec, lambda0, thetavec, wvec)
  #cat("!!"); print(range(nluvec-int.lambda.vec))
  #all(k2vec==kmaxp2 | svec[k1vec]<= nluvec & nluvec <= svec[k2vec])
  #int.lambda.vec <- int.lambda.func(othetavec, thetavec, wvec, lambda0, "DFR")
  #range(svec-int.lambda.vec)
  #uvec <- exp(-nluvec)
  #all(k2vec==kmaxp2 | svec[k1vec]<= nluvec & nluvec <= svec[k2vec])
  #all(k2vec==kmaxp2 | othetavec[k1vec] <= tvec & tvec <= othetavec[k2vec])
  #k2vec==kmaxp2 | othetavec[k1vec] <= tvec & tvec <= othetavec[k2vec]
  #all(k2vec==kmaxp2 | (exp(-int.lambda.vec[k2vec])<= uvec & uvec <= exp(-int.lambda.vec[k1vec])))
  return(tvec)
}

#' @export
rfail.sbt <- function(n, lambda0, thetavec1, wvec1, thetavec2, wvec2) {
  # simulate failure times from an SBT model 
  tvec <- pmin(rfail.dfr(n, 0, thetavec1, wvec1),
               rfail.ifr(n, lambda0, thetavec2, wvec2))
  return(tvec)
}


#' @export
rfail.mbt <- function(n, pival, lambda01, thetavec1, wvec1, 
                                lambda02, thetavec2, wvec2) {
  # simulate failure times from an MBT model 
  
  # Numbers selected from DFR and IFR components respectively
  n1 <- rbinom(1, n, pival)
  n2 <- n-n1
  tvec1 <- rfail.dfr(n1, 0, thetavec1, wvec1)
  tvec2 <- rfail.ifr(n2, 0, thetavec2, wvec2)
  # Combine and shuffle
  tvec <- sample(c(tvec1,tvec2))
  return(tvec)
}  

#' @export
rfail.lcv <- function(n, lambda0, w0, thetavec, wvec) {
  # simulate failure times from an LCV model
  odx <- order(thetavec) 
  othetavec <- thetavec[odx]  # theta*_k (1...K)
  owvec <- wvec[odx]          # w*_k     (1...K)
  kmax <- length(othetavec)   # K
  othetavec <- c(0,othetavec,1.1*othetavec[kmax]) # 0, thetavec, 1.1*last
  owvec <- c(0,owvec,0)                           # 0, wvec,     0
  kmaxp2 <- kmax+2            # K+2
  
  s1vec <- cumsum(owvec)
  s01vec <- w0 + s1vec
  s2vec <- cumsum(owvec*othetavec)
  ccvec <- lambda0*exp(-s2vec)/s01vec
  ccvec1 <- ccvec[-kmaxp2]
  s01vec1 <- s01vec[-kmaxp2]
  csvec1 <- ccvec1*(exp(s01vec1*othetavec[-1])-exp(s01vec1*othetavec[-kmaxp2]))
  csvec1 <- ifelse(s01vec1==0, 
                   lambda0*exp(-s2vec[-kmaxp2])*(othetavec[-1]-othetavec[-kmaxp2]), 
                   csvec1)
  ssvec <- c(0,cumsum(csvec1))
  
  nluvec <- -log(runif(n,0,1))
  k1vec <- apply(outer(nluvec, ssvec, function(nlu,ilamval) ilamval<=nlu),1,sum)
  k1vec <- pmax(1,k1vec)
  
  tvec <- ifelse(s01vec[k1vec]==0,
                 othetavec[k1vec] + (nluvec-ssvec[k1vec])/(lambda0*exp(-s2vec[k1vec])),
                 (1/s01vec[k1vec])*log(
                   exp(s01vec[k1vec]*othetavec[k1vec])
                   + (nluvec-ssvec[k1vec])/ccvec[k1vec]) 
  )
  
  # check 
  #int.lambda.vec <- int.lambda.func.lcv(tvec, lambda0, w0, thetavec, wvec)
  #cat("!!"); print(range(nluvec-int.lambda.vec))
  
  return(tvec)
}  

#' Simulate from a CIR model
#' 
#' @param n Number of failure times to simulate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param lambda0 Offset to be added to the hazard rate
#' 
#' @export
rfail.cir <- function(n, lambda0, thetavec, wvec) {
  # simulate failure times from a CIR model, 
  # given a set of weights and locations
  odx <- order(thetavec)
  othetavec <- thetavec[odx]
  owvec <- wvec[odx]
  kmax <- length(othetavec)
  othetavec <- c(0,othetavec,1.1*othetavec[kmax])
  owvec <- c(0,owvec,0)
  kmaxp2 <- kmax+2
  nluvec <- -log(runif(n,0,1))
  
  s1vec <- cumsum(owvec)
  s2vec <- cumsum(owvec*othetavec)
  s3vec <- cumsum(owvec*othetavec^2)

  svec <- s3vec + (lambda0-s2vec)*othetavec + 0.5*s1vec*othetavec^2
  k1vec <- apply(outer(nluvec, svec, function(nlu,s) nlu>=s),1,sum)
  k1vec <- pmin(k1vec,kmaxp2-1)
  
  avec <- 0.5*s1vec[k1vec]
  bvec <- lambda0 - s2vec[k1vec]
  cvec <- s3vec[k1vec]-nluvec

  tvec <- (0.5/avec)*( -bvec + sqrt(bvec^2 - 4*avec*cvec) )
  
  # check 
  #int.lambda.vec <- int.lambda.func.ifr(tvec, lambda0, thetavec, wvec)
  #cat("!!"); print(range(nluvec-int.lambda.vec))
  #all( tvec>othetavec[kmaxp2] | exp(-int.lambda.vec[k2vec+1])<= uvec & uvec <= exp(-int.lambda.vec[k1vec+1]) )
  #all( tvec>othetavec[kmaxp2] | (othetavec[k2vec] <= tvec & tvec <= othetavec[k2vec+1]) )
  #all( nluvec>svec[kmaxp2-1] | svec[k1vec]<= nluvec & nluvec <= svec[k2vec] )
  
  return(tvec)
}

#' Simulate from a CDR model
#' 
#' @param n Number of failure times to simulate
#' @param thetavec Set of support locations
#' @param wvec Set of associated weights
#' @param lambda0 Offset to be added to the hazard rate
#' 
#' @export
rfail.cdr <- function(n, lambda0, thetavec, wvec) {
  # simulate failure times from a CDR model, 
  # given a set of weights and locations
  odx <- order(thetavec)
  othetavec <- thetavec[odx]
  owvec <- wvec[odx]
  kmax <- length(othetavec)
  othetavec <- c(0,othetavec,1.1*othetavec[kmax])
  owvec <- c(0,owvec,0)
  kmaxp2 <- kmax+2
  nluvec <- -log(runif(n,0,1))
  
  s1vec <- cumsum(owvec)
  s2vec <- cumsum(owvec*othetavec)
  s3vec <- cumsum(owvec*othetavec^2)
  
  svec <- s3vec + (lambda0-s2vec)*othetavec + 0.5*s1vec*othetavec^2
  k1vec <- apply(outer(nluvec, svec, function(nlu,s) nlu>=s),1,sum)
  k1vec <- pmin(k1vec,kmaxp2-1)
  
  avec <- -0.5*(s1vec[kmaxp2]-s1vec[k1vec])
  bvec <- lambda0 + (s2vec[kmaxp2]-s2vec[k1vec])
  cvec <- 0.5*s3vec[k1vec]-nluvec
  
  tvec <- (0.5/avec)*( -bvec + sqrt(bvec^2 - 4*avec*cvec) )

  # check 
  #int.lambda.vec <- int.lambda.func.ifr(tvec, lambda0, thetavec, wvec)
  #cat("!!"); print(range(nluvec-int.lambda.vec))
  #all( tvec>othetavec[kmaxp2] | exp(-int.lambda.vec[k2vec+1])<= uvec & uvec <= exp(-int.lambda.vec[k1vec+1]) )
  #all( tvec>othetavec[kmaxp2] | (othetavec[k2vec] <= tvec & tvec <= othetavec[k2vec+1]) )
  #all( nluvec>svec[kmaxp2-1] | svec[k1vec]<= nluvec & nluvec <= svec[k2vec] )
  
  return(tvec)
}


#' @export
rfail.cvx <- function(n, lambda0, thetavec1, wvec1, thetavec2, wvec2) {
  # simulate failure times from a CVX model 
  tvec <- pmin(rfail.cdr(n, 0, thetavec1, wvec1),
               rfail.cir(n, lambda0, thetavec2, wvec2))
  return(tvec)
}

#' @export
rfail.mew <- function(n, lambda, alpha, theta, gamma) {
  # simulate failure times from an MEW model
  epsilon <- .Machine$double.eps
  uvec <- runif(n, epsilon, 1-epsilon)
  ff <- function(x, lambda, alpha, cc) {
      v <- x/(1-x)
      return(lambda*v + v^alpha - cc)
  }
  xvec <- sapply(-log(uvec),
                   function(cc) {
                     uniroot(ff, 
                             interval=c(epsilon, 1-epsilon), 
                             lambda=lambda, 
                             alpha=alpha,
                             cc=cc)$root
                   })
  tvec <- theta*( -log(1-xvec) )^(1/gamma) 
  #print(cbind(-log(uvec),xvec,tvec))
  return(tvec)
}
  
###############################################################################
#' Log likelihood of failure data
#' 
#' @param tvec Vector of failure times
#' @param model.list Model specification
#' @param tau Censoring time
#' @param use.Cpp Use C++ functions for speed
#' 
#' @export
llike.fail <- function(tvec, model.list, tau=Inf, use.Cpp=TRUE) {
  # log likelihood of observations tvec (censored at tau)
  n <- length(tvec)
  censored <- tvec>=tau
  n0 <- n-sum(censored)
  tvec <- pmin(tvec,tau)
  
  lambda.vec <- lambda.func(tvec, model.list, use.Cpp=use.Cpp)
  int.lambda.vec <- int.lambda.func(tvec, model.list, use.Cpp=use.Cpp)
  
  retval <- sum(log(lambda.vec[!censored])) - sum(int.lambda.vec)
  return(retval)
}
###############################################################################



