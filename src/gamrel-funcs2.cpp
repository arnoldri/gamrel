#include <Rcpp.h>
#include <algorithm>
using namespace Rcpp;

//--// [[Rcpp::depends(fntl)]]
//--#include "fntl.h"

//' C version of order() - bad performance with duplicates
//' 
//' @export
// [[Rcpp::export]]
IntegerVector orderfunc_c(NumericVector x) {
 if (is_true(any(duplicated(x)))) {
   Rf_warning("There are duplicates in 'x'; order not guaranteed to match that of R's base::order");
 }
 NumericVector sorted = clone(x).sort();
 return match(sorted, x);
}

//' C version of mean()
//' 
//' @export
// [[Rcpp::export]]
double meanfunc_c(NumericVector x) {
 int n = x.size();
 double total = 0;
 
 for(int i = 0; i < n; ++i) {
   total += x[i];
 }
 return total / n;
}

//' Make DPP beta draws given a set of unscaled stick breaking weights
//' 
//' @export
// [[Rcpp::export]]
NumericVector makev_c(NumericVector uvec) {
 
 int kmax = uvec.size();
 NumericVector vvec(kmax);
 int k;
 double cp;
 
 vvec[0] = uvec[0];
 if(kmax>1) {
   cp = 1.0;
   for(k=1; k<kmax-1; k++) {
     vvec[k] = uvec[k]/(cp-uvec[k-1]);
     cp = cp*(1-vvec[k-1]);
   }
   vvec[kmax-1] = 0.5;
 }
 
 return vvec;
}

 

//**********************************************************************
//* CON - Constant Hazard Rate
//**********************************************************************
//' Hazard rate function - CON
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' 
//' @description Hazard rate function for constant hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_con_c(NumericVector tvec,
                        double lambda0 
) {
 int n = tvec.size();
 NumericVector lambdavec(n);
 int i;
 
 for(i=0; i<n; i++) {
   lambdavec[i] = lambda0;
 }
 
 return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - CON
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' 
//' @description Integrated hazard rate function for constant hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_con_c(NumericVector tvec,
                         double lambda0 
) {
  int n = tvec.size();
  NumericVector clambdavec(n);
  int i;
  
  for(i=0; i<n; i++) {
    clambdavec[i] = lambda0*tvec[i];
  }
  
  return clambdavec;
}

//*************************************************************************
//' Hazard and Integrated Hazard rate functions - CON
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_con_c(NumericVector tvec,
                              double lambda0) {
 int n = tvec.size();
 NumericMatrix haz_chz_mat(n,2);
 int i;
 
 for(i=0; i<n; i++) {
   haz_chz_mat(i,0) = lambda0;
   haz_chz_mat(i,1) = lambda0*tvec[i];
 }
 
 return haz_chz_mat;
}


//**********************************************************************
//' Inverse survival function - CON
//' 
//' @param uvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' 
//' @description Inverse survival function for constant hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector invsurvf_con_c(NumericVector uvec,
                             double lambda0
) {
  int n = uvec.size();
  NumericVector tvec(n);
  int i;
  
  for(i=0; i<n; i++) {
    tvec[i] = -log(uvec[i])/lambda0;
  }
  
  return tvec;
}


//**********************************************************************
//' Log prior - CON
//' 
//' 
//' @param lambda0 lambda0: constant hazard rate
//' @param nu exponential prior
//' 
//' @description log(prior) for the CON model - in vector form
//' 
//' @export
// [[Rcpp::export]]
NumericVector logprior_con_c(double lambda0, double s1, double s2) {

 NumericVector lpriorvec(1);

 // lambda0
 lpriorvec[0] = R::dgamma(lambda0, s1, 1./s2, true);

 return lpriorvec;
}   


//**********************************************************************
//* IFR - Increasing hazard rate
//**********************************************************************
//' Hazard rate function - IFR
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate function for IFR hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_ifr_c(NumericVector tvec,
                         double lambda0, 
                         NumericVector thetavec, 
                         NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector lambdavec(n);
 int i, k;
 
 for(i=0; i<n; i++) {
   lambdavec[i] = lambda0;
   for(k=0; k<kmax; k++) {
     if(thetavec[k]<tvec[i]) lambdavec[i] += wvec[k];
   }
 }
 
 return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - IFR
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Integrated hazard rate function for IFR hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_ifr_c(NumericVector tvec,
                         double lambda0,
                         NumericVector thetavec, 
                         NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector clambdavec(n);
 int i, k;
 
 for(i=0; i<n; i++) {
   clambdavec[i] = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(thetavec[k]<tvec[i]) clambdavec[i] += wvec[k]*(tvec[i]-thetavec[k]);
   }
 }
 
 return clambdavec;
}

//*************************************************************************
//' Hazard and Integrated Hazard rate functions - IFR
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_ifr_c(NumericVector tvec,
                             double lambda0,
                             NumericVector thetavec, 
                             NumericVector wvec) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericMatrix haz_chz_mat(n,2);
 int i, k;
 
 for(i=0; i<n; i++) {
   haz_chz_mat(i,0) = lambda0;
   haz_chz_mat(i,1) = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(thetavec[k]<tvec[i]) {
       haz_chz_mat(i,0) += wvec[k];
       haz_chz_mat(i,1) += wvec[k]*(tvec[i]-thetavec[k]); 
     }
   }
 }
 
 return haz_chz_mat;
}

//**********************************************************************
//' Log prior - IFR/DFR
//' 
//' 
//' @param eta eta
//' @param gamma gamma
//' 
//' @description log(prior) for the IFR and DFR models - in vector form
//' 
//' @export
// [[Rcpp::export]]
NumericVector logprior_ifrdfr_c(double eta, 
                               double gamma,
                               NumericVector thetavec, 
                               NumericVector vvec,
                               double alpha, 
                               double beta,
                               double phi,
                               double nu, double a1, double a2, double b1, double b2, double f1, double f2) {
   
   int kmax = vvec.size();
   NumericVector lpriorvec(7);
   int i;
 
   // eta
   lpriorvec[0] = -eta*nu;
   // gamma
   lpriorvec[1] = R::dgamma(gamma, alpha, 1./beta, true);
   // thetavec
   lpriorvec[2] = kmax*log(phi);
   for(i=0; i<kmax; i++) lpriorvec[2] += (-phi*thetavec[i]);
   // vvec
   lpriorvec[3] =  (kmax-1)*log(alpha);
   for(i=0; i<kmax-1; i++) lpriorvec[3] += (alpha-1)*log(1-vvec[i]);
   // alpha
   lpriorvec[4] = (a1-1)*log(alpha) - a2*alpha;
   // beta
   lpriorvec[5] = (b1-1)*log(beta) - b2*beta;
   // phi
   lpriorvec[6] = (f1-1)*log(phi) - f2*phi;
 
 return lpriorvec;
}   

//**********************************************************************
//* DFR - Decreasing hazard rate
//**********************************************************************
//' Hazard rate function - DFR
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate function for DFR hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_dfr_c(NumericVector tvec,
                         double lambda0, 
                         NumericVector thetavec, 
                         NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector lambdavec(n);
 int i, k;

 for(i=0; i<n; i++) {
   lambdavec[i] = lambda0;
   for(k=0; k<kmax; k++) {
     if(thetavec[k]>tvec[i]) lambdavec[i] += wvec[k];
   }
 }
 
 return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - DFR
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Integrated hazard rate function for DFR hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_dfr_c(NumericVector tvec,
                         double lambda0,
                         NumericVector thetavec, 
                         NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector clambdavec(n);
 int i, k;

 for(i=0; i<n; i++) {
   clambdavec[i] = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(thetavec[k]<tvec[i]) {
       clambdavec[i] += wvec[k]*thetavec[k]; 
     } else {
       clambdavec[i] += wvec[k]*tvec[i]; 
     }
   }
 }

 return clambdavec;
}

//*************************************************************************
//' Hazard and Integrated Hazard rate functions - DFR
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_dfr_c(NumericVector tvec,
                              double lambda0,
                              NumericVector thetavec, 
                              NumericVector wvec) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericMatrix haz_chz_mat(n,2);
 int i, k;

 for(i=0; i<n; i++) {
   haz_chz_mat(i,0) = lambda0;
   haz_chz_mat(i,1) = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(thetavec[k]<tvec[i]) {
       haz_chz_mat(i,1) += wvec[k]*thetavec[k]; 
     } else {
       haz_chz_mat(i,0) += wvec[k]; 
       haz_chz_mat(i,1) += wvec[k]*tvec[i]; 
     }
   }
 }

 return haz_chz_mat;
}

/* Log Prior for DFR is the same as for IFR - see above */

//**********************************************************************
//* CIR - Piecewise linear increasing hazard rate
//**********************************************************************
//' Hazard rate function - CIR
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate function for CIR hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_cir_c(NumericVector tvec,
                         double lambda0, 
                         NumericVector thetavec, 
                         NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector lambdavec(n);
 int i, k;
 
 for(i=0; i<n; i++) {
   lambdavec[i] = lambda0;
   for(k=0; k<kmax; k++) {
     if(thetavec[k]<tvec[i]) lambdavec[i] += wvec[k]*(tvec[i]-thetavec[k]);
   }
 }
 
 return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - CIR
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Integrated hazard rate function for CIR hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_cir_c(NumericVector tvec,
                         double lambda0,
                         NumericVector thetavec, 
                         NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector clambdavec(n);
 int i, k;
 
 for(i=0; i<n; i++) {
   clambdavec[i] = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(thetavec[k]<tvec[i]) clambdavec[i] += 0.5*wvec[k]*pow(tvec[i]-thetavec[k],2);
   }
 }
 
 return clambdavec;
}

//*************************************************************************
//' Hazard and Integrated Hazard rate functions - CIR
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_cir_c(NumericVector tvec,
                              double lambda0,
                              NumericVector thetavec, 
                              NumericVector wvec) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericMatrix haz_chz_mat(n,2);
 int i, k;
 
 for(i=0; i<n; i++) {
   haz_chz_mat(i,0) = lambda0;
   haz_chz_mat(i,1) = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(thetavec[k]<tvec[i]) {
       haz_chz_mat(i,0)+= wvec[k]*(tvec[i]-thetavec[k]);
       haz_chz_mat(i,1) += 0.5*wvec[k]*pow(tvec[i]-thetavec[k],2); 
     } 
   }
 }

 return haz_chz_mat;
}





//**********************************************************************
//* CDR - Piecewise linear decreasing hazard rate
//**********************************************************************
//' Hazard rate function - CDR
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate function for CDR hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_cdr_c(NumericVector tvec,
                        double lambda0, 
                        NumericVector thetavec, 
                        NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector lambdavec(n);
 int i, k;
 
 for(i=0; i<n; i++) {
   lambdavec[i] = lambda0;
   for(k=0; k<kmax; k++) {
     if(thetavec[k]>tvec[i]) lambdavec[i] += wvec[k]*(thetavec[k]-tvec[i]);
   }
 }
 
 return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - CDR
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Integrated hazard rate function for CIR hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_cdr_c(NumericVector tvec,
                         double lambda0,
                         NumericVector thetavec, 
                         NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector clambdavec(n);
 int i, k;
 
 for(i=0; i<n; i++) {
   clambdavec[i] = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     clambdavec[i] += 0.5*wvec[k]*pow(thetavec[k],2);
     if(thetavec[k]>tvec[i]) clambdavec[i] += -0.5*wvec[k]*pow(thetavec[k]-tvec[i],2);
   }
 }
 
 return clambdavec;
}


//*************************************************************************
//' Hazard and Integrated Hazard rate functions - CDR
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_cdr_c(NumericVector tvec,
                              double lambda0,
                              NumericVector thetavec, 
                              NumericVector wvec) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericMatrix haz_chz_mat(n,2);
 int i, k;
 
 for(i=0; i<n; i++) {
   haz_chz_mat(i,0) = lambda0;
   haz_chz_mat(i,1) = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     haz_chz_mat(i,1) += 0.5*wvec[k]*pow(thetavec[k],2);
     if(thetavec[k]>tvec[i]) {
       haz_chz_mat(i,0)+= wvec[k]*(thetavec[k]-tvec[i]);
       haz_chz_mat(i,1) += -0.5*wvec[k]*pow(thetavec[k]-tvec[i],2);
     } 
   }
 }
 
 return haz_chz_mat;
}


//**********************************************************************
//* LWB - Decreasing hazard rate
//**********************************************************************
//' Hazard rate function - LWB
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param a Change point
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate function for LWB hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_lwb_c(NumericVector tvec,
                         double lambda0, 
                         double a, 
                         NumericVector thetavec, 
                         NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector lambdavec(n);
 int i, k;
 
 for(i=0; i<n; i++) {
   lambdavec[i] = lambda0;
   for(k=0; k<kmax; k++) {
     if(  (tvec[i]<a-thetavec[k])
        ||(tvec[i]>a+thetavec[k]) ) lambdavec[i] += wvec[k];
   }
 }
 
 return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - LWB
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param a Change point
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Integrated hazard rate function for LWB hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_lwb_c(NumericVector tvec,
                         double lambda0,
                         double a,
                         NumericVector thetavec, 
                         NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector clambdavec(n);
 int i, k;
 
 for(i=0; i<n; i++) {
   clambdavec[i] = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(tvec[i]<a) {
       if(thetavec[k]<a) {
          clambdavec[i] += wvec[k]*std::min(tvec[i],a-thetavec[k]);
       }
     } else {
       if(thetavec[k]<a) {
         clambdavec[i] += wvec[k]*(a-thetavec[k]);
       }
       if(thetavec[k]<tvec[i]-a) {
         clambdavec[i] += wvec[k]*(tvec[i]-a-thetavec[k]);
       }
     }
   }
 }
 
 return clambdavec;
}

//*************************************************************************
//' Hazard and Integrated Hazard rate functions - LWB
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param a Change point
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_lwb_c(NumericVector tvec,
                              double lambda0,
                              double a,
                              NumericVector thetavec, 
                              NumericVector wvec) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericMatrix haz_chz_mat(n,2);
 int i, k;
 
 for(i=0; i<n; i++) {
   haz_chz_mat(i,0) = lambda0;
   haz_chz_mat(i,1) = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(tvec[i]<a) {
       if(tvec[i]<a-thetavec[k]) {
         haz_chz_mat(i,0) += wvec[k];
       }
       if(thetavec[k]<a) {
         haz_chz_mat(i,1) += wvec[k]*std::min(tvec[i],a-thetavec[k]);
       }
     } else {
       if(thetavec[k]<a) {
         haz_chz_mat(i,1) += wvec[k]*(a-thetavec[k]);
       }
       if(thetavec[k]<tvec[i]-a) {
         haz_chz_mat(i,0) += wvec[k];
         haz_chz_mat(i,1) += wvec[k]*(tvec[i]-a-thetavec[k]);
       }
     }
   }
 }
 
 return haz_chz_mat;
}

//**********************************************************************
//* HBT - Ho Bathtub
//**********************************************************************
//' Hazard rate function - HBT
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param a Change point
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate function for HBT hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_hbt_c(NumericVector tvec,
                         double lambda0, 
                         double a, 
                         NumericVector thetavec, 
                         NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector lambdavec(n);
 int i, k;
 
 for(i=0; i<n; i++) {
   lambdavec[i] = lambda0;
   for(k=0; k<kmax; k++) {
     if(   (tvec[i]<a && tvec[i]<thetavec[k] && thetavec[k]<a)
        || (tvec[i]>a && a<thetavec[k] && thetavec[k]<tvec[i]) ) {
       lambdavec[i] += wvec[k]; 
     }
   }
 }
 
 return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - HBT
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param a Change point
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Integrated hazard rate function for HBT hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_hbt_c(NumericVector tvec,
                         double lambda0,
                         double a,
                         NumericVector thetavec, 
                         NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector clambdavec(n);
 int i, k;
  
 for(i=0; i<n; i++) {
   clambdavec[i] = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(tvec[i]<a) {
       if(thetavec[k]<a) {
          clambdavec[i] += wvec[k]*std::min(tvec[i],thetavec[k]);
       }
     } else {
       if(thetavec[k]<a) {
         clambdavec[i] += wvec[k]*thetavec[k]; 
       } else {
         clambdavec[i] += wvec[k]*std::max(tvec[i]-thetavec[k],0.0);
       }
     }
   }
 }
 
 return clambdavec;
}

//*************************************************************************
//' Hazard and Integrated Hazard rate functions - HBT
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param a Change point
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_hbt_c(NumericVector tvec,
                              double lambda0,
                              double a,
                              NumericVector thetavec, 
                              NumericVector wvec) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericMatrix haz_chz_mat(n,2);
 int i, k;

 for(i=0; i<n; i++) {
   haz_chz_mat(i,0) = lambda0;
   haz_chz_mat(i,1) = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(tvec[i]<a) {
       if(thetavec[k]<a) {
         if(tvec[i]<thetavec[k]) haz_chz_mat(i,0) += wvec[k]; 
         haz_chz_mat(i,1) += wvec[k]*std::min(tvec[i],thetavec[k]);
       }
     } else {
       if(thetavec[k]<a) {
         haz_chz_mat(i,1) += wvec[k]*thetavec[k]; 
       } else {
         if(thetavec[k]<tvec[i]) haz_chz_mat(i,0) += wvec[k];
         haz_chz_mat(i,1) += wvec[k]*std::max(tvec[i]-thetavec[k],0.0);
       }
     }
   }
 }
 
 return haz_chz_mat;
}


//**********************************************************************
//* HCV - Convex Ho Bathtub
//**********************************************************************
//' Hazard rate function - HCV
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param a Change point
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate function for HCV hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_hcv_c(NumericVector tvec,
                         double lambda0, 
                         double a, 
                         NumericVector thetavec, 
                         NumericVector wvec) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector lambdavec(n);
 int i, k;
 
 for(i=0; i<n; i++) {
   lambdavec[i] = lambda0;
   for(k=0; k<kmax; k++) {
     if( (tvec[i]<a && tvec[i]<thetavec[k] && thetavec[k]<a) ) {
       lambdavec[i] += wvec[k]*(thetavec[k]-tvec[i]); 
     } else if( (tvec[i]>a && a<thetavec[k] && thetavec[k]<tvec[i]) ) {
       lambdavec[i] += wvec[k]*(tvec[i]-thetavec[k]); 
     }
   }
 }
 
 return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - HCV
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param a Change point
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Integrated hazard rate function for HCV hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_hcv_c(NumericVector tvec,
                         double lambda0,
                         double a,
                         NumericVector thetavec, 
                         NumericVector wvec) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector clambdavec(n);
 int i, k;
 
 for(i=0; i<n; i++) {
   clambdavec[i] = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(tvec[i]<a) {
       if(thetavec[k]<a) {
          clambdavec[i] += +0.5*wvec[k]*pow(thetavec[k],2);
          clambdavec[i] += -0.5*wvec[k]*pow(std::max(thetavec[k]-tvec[i],0.0),2);
       }
     } else {
       if(thetavec[k]<a) {
         clambdavec[i] += 0.5*wvec[k]*pow(thetavec[k],2); 
       } else if(a<thetavec[k] && thetavec[k]<tvec[i]) {
         clambdavec[i] += 0.5*wvec[k]*pow(tvec[i]-thetavec[k],2);
       }
     }
   }
 }
 
 return clambdavec;
}

//*************************************************************************
//' Hazard and Integrated Hazard rate functions - HCV
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param a Change point
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_hcv_c(NumericVector tvec,
                              double lambda0,
                              double a,
                              NumericVector thetavec, 
                              NumericVector wvec) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericMatrix haz_chz_mat(n,2);
 int i, k;
 
 for(i=0; i<n; i++) {
   haz_chz_mat(i,0) = lambda0;
   haz_chz_mat(i,1) = lambda0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(tvec[i]<a) {
       if(thetavec[k]<a) {
         haz_chz_mat(i,1) += +0.5*wvec[k]*pow(thetavec[k],2);
         if(tvec[i]<thetavec[k]) {
           haz_chz_mat(i,0) +=  wvec[k]*(thetavec[k]-tvec[i]); 
           haz_chz_mat(i,1) += -0.5*wvec[k]*pow(thetavec[k]-tvec[i],2);
         }
       }
     } else {
       if(thetavec[k]<a) {
         haz_chz_mat(i,1) += 0.5*wvec[k]*pow(thetavec[k],2);
       } else if(a<thetavec[k]) {
         if(thetavec[k]<tvec[i] ) {
           haz_chz_mat(i,0) += wvec[k]*(tvec[i]-thetavec[k]); 
           haz_chz_mat(i,1) += 0.5*wvec[k]*pow(tvec[i]-thetavec[k],2); 
         }
       }
     }
   }
 }

 return haz_chz_mat;
}

//**********************************************************************
//* SBT - Superposition Bathtub
//**********************************************************************
//' Hazard rate function - SBT
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec1 DFR Locations
//' @param wvec1 DFR Weights
//' @param thetavec2 IFR Locations
//' @param wvec2 IFR Weights
//' 
//' @description Hazard rate function for SBT hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_sbt_c(NumericVector tvec,
                         double lambda0, 
                         NumericVector thetavec1, 
                         NumericVector wvec1,
                         NumericVector thetavec2, 
                         NumericVector wvec2) {
 int n = tvec.size();
 NumericVector lambdavec(n);

 lambdavec = hazf_dfr_c(tvec, lambda0, thetavec1, wvec1);
 lambdavec += hazf_ifr_c(tvec, (double) 0.0, thetavec2, wvec2);

 return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - SBT
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec1 DFR Locations
//' @param wvec1 DFR Weights
//' @param thetavec2 IFR Locations
//' @param wvec2 IFR Weights
//' @param lambda0 Offset to be added to the hazard rate
//' 
//' @description Integrated hazard rate function for SBT hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_sbt_c(NumericVector tvec,
                         double lambda0,
                         NumericVector thetavec1, 
                         NumericVector wvec1,
                         NumericVector thetavec2, 
                         NumericVector wvec2) {
 int n = tvec.size();
 NumericVector clambdavec(n);
 
 clambdavec = chzf_dfr_c(tvec, lambda0, thetavec1, wvec1);
 clambdavec += chzf_ifr_c(tvec, (double) 0.0, thetavec2, wvec2);

 return clambdavec;
}

//*************************************************************************
//' Hazard and Integrated Hazard rate functions - SBT
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec1 DFR Locations
//' @param wvec1 DFR Weights
//' @param thetavec2 IFR Locations
//' @param wvec2 IFR Weights
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_sbt_c(NumericVector tvec,
                              double lambda0,
                              NumericVector thetavec1, 
                              NumericVector wvec1,
                              NumericVector thetavec2, 
                              NumericVector wvec2) {

 int n = tvec.size();
 NumericMatrix haz_chz_mat(n,2);

 haz_chz_mat = hazf_chzf_dfr_c(tvec, lambda0, thetavec1, wvec1);
 haz_chz_mat += hazf_chzf_ifr_c(tvec, (double) 0.0, thetavec2, wvec2);
 
 return haz_chz_mat;
}


//**********************************************************************
//* SCV - Convex Superposition Bathtub
//**********************************************************************
//' Hazard rate function - SCV
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec1 DFR Locations
//' @param wvec1 DFR Weights
//' @param thetavec2 IFR Locations
//' @param wvec2 IFR Weights
//' 
//' @description Hazard rate function for SCV hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_scv_c(NumericVector tvec,
                         double lambda0, 
                         NumericVector thetavec1, 
                         NumericVector wvec1,
                         NumericVector thetavec2, 
                         NumericVector wvec2) {
 int n = tvec.size();
 NumericVector lambdavec(n);
 
 lambdavec = hazf_cdr_c(tvec, lambda0, thetavec1, wvec1);
 lambdavec += hazf_cir_c(tvec, (double) 0.0, thetavec2, wvec2);
 
 return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - SCV
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec1 DFR Locations
//' @param wvec1 DFR Weights
//' @param thetavec2 IFR Locations
//' @param wvec2 IFR Weights
//' @param lambda0 Offset to be added to the hazard rate
//' 
//' @description Integrated hazard rate function for SCV hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_scv_c(NumericVector tvec,
                         double lambda0,
                         NumericVector thetavec1, 
                         NumericVector wvec1,
                         NumericVector thetavec2, 
                         NumericVector wvec2) {
 int n = tvec.size();
 NumericVector clambdavec(n);
 
 clambdavec = chzf_cdr_c(tvec, lambda0, thetavec1, wvec1);
 clambdavec += chzf_cir_c(tvec, (double) 0.0, thetavec2, wvec2);
 
 return clambdavec;
}

//*************************************************************************
//' Hazard and Integrated Hazard rate functions - SCV
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec1 DFR Locations
//' @param wvec1 DFR Weights
//' @param thetavec2 IFR Locations
//' @param wvec2 IFR Weights
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_scv_c(NumericVector tvec,
                              double lambda0,
                              NumericVector thetavec1, 
                              NumericVector wvec1,
                              NumericVector thetavec2, 
                              NumericVector wvec2) {
 
 int n = tvec.size();
 NumericMatrix haz_chz_mat(n,2);
 
 haz_chz_mat = hazf_chzf_cdr_c(tvec, lambda0, thetavec1, wvec1);
 haz_chz_mat += hazf_chzf_cir_c(tvec, (double) 0.0, thetavec2, wvec2);
 
 return haz_chz_mat;
}


//**********************************************************************
//* MBT - Mixture Bathtub
//**********************************************************************
//' Hazard rate function - MBT
//' 
//' @param tvec Locations at which to evaluate the function
//' @param pival Proportion of the mixture in the DFR component
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec1 DFR Locations
//' @param wvec1 DFR Weights
//' @param thetavec2 IFR Locations
//' @param wvec2 IFR Weights
//' 
//' @description Hazard rate function for MBT hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_mbt_c(NumericVector tvec,
                         double pival,
                         double lambda0, 
                         NumericVector thetavec1, 
                         NumericVector wvec1,
                         NumericVector thetavec2, 
                         NumericVector wvec2) {
 int n = tvec.size();
 NumericVector lambdavec(n);
 NumericMatrix haz_chz_mat1(n,2);
 NumericMatrix haz_chz_mat2(n,2);
 int i;
 double fbar1, fbar2;
 double num, den;
 
 haz_chz_mat1 = hazf_chzf_dfr_c(tvec, lambda0, thetavec1, wvec1);
 haz_chz_mat2 = hazf_chzf_ifr_c(tvec, (double) 0.0, thetavec2, wvec2);

 for(i=0; i<n; i++) {
   fbar1 = exp(-haz_chz_mat1(i,1));
   fbar2 = exp(-haz_chz_mat2(i,1));
   num = pival*haz_chz_mat1(i,0)*fbar1 + (1-pival)*haz_chz_mat2(i,0)*fbar2;
   den = pival*fbar1 + (1-pival)*fbar2;
   lambdavec[i] = num/den;
 }
 
 return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - MBT
//' 
//' @param tvec Locations at which to evaluate the function
//' @param pival Proportion of the mixture in the DFR component
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec1 DFR Locations
//' @param wvec1 DFR Weights
//' @param thetavec2 IFR Locations
//' @param wvec2 IFR Weights
//' @param lambda0 Offset to be added to the hazard rate
//' 
//' @description Integrated hazard rate function for MBT hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_mbt_c(NumericVector tvec,
                         double pival,
                         double lambda0,
                         NumericVector thetavec1, 
                         NumericVector wvec1,
                         NumericVector thetavec2, 
                         NumericVector wvec2) {
 int n = tvec.size();
 NumericVector fbar1(n);
 NumericVector fbar2(n);
 NumericVector clambdavec(n);

 fbar1 = exp(-chzf_dfr_c(tvec, lambda0, thetavec1, wvec1));
 fbar2 = exp(-chzf_ifr_c(tvec, (double) 0.0, thetavec2, wvec2));
 
 clambdavec = -log(pival*fbar1 + (1-pival)*fbar2);
 
 return clambdavec;
}

//*************************************************************************
//' Hazard and Integrated Hazard rate functions - MBT
//' 
//' @param tvec Locations at which to evaluate the function
//' @param pival Proportion of the mixture in the DFR component
//' @param lambda0 Offset to be added to the hazard rate
//' @param thetavec1 DFR Locations
//' @param wvec1 DFR Weights
//' @param thetavec2 IFR Locations
//' @param wvec2 IFR Weights
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_mbt_c(NumericVector tvec,
                              double pival,
                              double lambda0,
                              NumericVector thetavec1, 
                              NumericVector wvec1,
                              NumericVector thetavec2, 
                              NumericVector wvec2) {
 
 int n = tvec.size();
 NumericMatrix haz_chz_mat1(n,2);
 NumericMatrix haz_chz_mat2(n,2);
 NumericMatrix haz_chz_mat(n,2);
 int i;
 double fbar1, fbar2;
 double num, den;

 haz_chz_mat1 = hazf_chzf_dfr_c(tvec, lambda0, thetavec1, wvec1);
 haz_chz_mat2 = hazf_chzf_ifr_c(tvec, (double) 0.0, thetavec2, wvec2);

 for(i=0; i<n; i++) {
   fbar1 = exp(-haz_chz_mat1(i,1));
   fbar2 = exp(-haz_chz_mat2(i,1));
   num = pival*haz_chz_mat1(i,0)*fbar1 + (1-pival)*haz_chz_mat2(i,0)*fbar2;
   den = pival*fbar1 + (1-pival)*fbar2;
   haz_chz_mat(i,0) = num/den;
   haz_chz_mat(i,1) = -log(den);
 }
 
 return haz_chz_mat;
}

//**********************************************************************
//* LCV - log convex
//**********************************************************************
//' Hazard rate function - LCV
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to scale the hazard rate
//' @param w0 Offset to be added to the slope of the log hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' 
//' @description Hazard rate function for LCV hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_lcv_c(NumericVector tvec,
                         double lambda0, 
                         double w0, 
                         NumericVector thetavec, 
                         NumericVector wvec
) {
 int n = tvec.size();
 int kmax = thetavec.size();
 NumericVector lambdavec(n);
 double loglambda;
 int i, k;
 
 for(i=0; i<n; i++) {
   loglambda = w0*tvec[i];
   for(k=0; k<kmax; k++) {
     if(thetavec[k]<tvec[i]) loglambda += wvec[k]*(tvec[i]-thetavec[k]);
   }
   lambdavec[i] = lambda0*exp(loglambda);
 }
 
 return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - LCV
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to scale the hazard rate
//' @param w0 Offset to be added to the slope of the log hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' @param epsilon Size of value close to zero
//' 
//' @description Integrated hazard rate function for LCV hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_lcv_c(NumericVector tvec,
                         double lambda0,
                         double w0,
                         NumericVector thetavec, 
                         NumericVector wvec,
                         double epsilon // needs 100*.Machine$double.neg.eps
) {
  int n = tvec.size();
  int kmax = thetavec.size();
  int kmaxp2 = kmax+2;
  NumericVector clambdavec(n);
  IntegerVector odx(kmax);
  NumericVector othetavec(kmaxp2);
  NumericVector owvec(kmaxp2);
  NumericVector s01vec(kmaxp2); 
  NumericVector s2vec(kmaxp2);
  NumericVector ccvec(kmaxp2);
  double cs;
  NumericVector ssvec(kmaxp2);
  int i,k,k1;
  
  odx = orderfunc_c(thetavec);
  othetavec[0] = 0;
  owvec[0] = 0;
  for(k=0; k<kmax; k++) {
    othetavec[k+1] = thetavec[odx[k]-1];
    owvec[k+1] = wvec[odx[k]-1];
  }
  othetavec[kmaxp2-1] = 1.1*othetavec[kmaxp2-2];
  owvec[kmaxp2-1] = 0;
  
  s01vec[0] = w0;
  s2vec[0] = 0;
  for(k=1; k<kmaxp2; k++) {
    s01vec[k] = s01vec[k-1] + owvec[k];   // w0+C
    s2vec[k] = s2vec[k-1] + owvec[k]*othetavec[k];  // D
  }
  
  ssvec[0] = 0;
  for(k=0; k<kmaxp2-1; k++) {
    ccvec[k] = lambda0*exp(-s2vec[k]);
    if(s01vec[k]==0) {
      cs = ccvec[k]*(othetavec[k+1]-othetavec[k]);
    } else {
      cs = (ccvec[k]/s01vec[k])*(exp(s01vec[k]*othetavec[k+1])-exp(s01vec[k]*othetavec[k]));
    }
    ssvec[k+1] = ssvec[k] + cs;
  }
  ccvec[kmaxp2-1] = ccvec[kmaxp2-2];
  
  // NumericVector excess(9);
  
  for(i=0; i<n; i++) {
    k1 = 0;
    while( (k1<kmaxp2-1) && (othetavec[k1+1]<=tvec[i]) ) {   // try < rather than <=?
      k1++;
    }
    clambdavec[i] = ssvec[k1];
    if(std::abs(s01vec[k1])<epsilon) {
      //excess[0] = -i;
      //excess[1] = k1;
      //excess[2] = othetavec[k1];
      //excess[3] = tvec[i];
      //excess[4] = othetavec[k1+1];
      //excess[5] = int_lambdavec[i];
      //excess[6] = ccvec[k1]*(tvec[i]-othetavec[k1]);
      //excess[7] = s01vec[k1];
      //excess[8] = ccvec[k1];
      clambdavec[i] += ccvec[k1]*(tvec[i]-othetavec[k1]);
    } else {
      //excess[0] = i;
      //excess[1] = k1;
      //excess[2] = othetavec[k1];
      //excess[3] = tvec[i];
      //excess[4] = othetavec[k1+1];
      //excess[5] = int_lambdavec[i];
      //excess[6] = (ccvec[k1]/s01vec[k1])*(exp(s01vec[k1]*tvec[i])-exp(s01vec[k1]*othetavec[k1]));
      //excess[7] = s01vec[k1];
      //excess[8] = ccvec[k1];
      clambdavec[i] += (ccvec[k1]/s01vec[k1])*(exp(s01vec[k1]*tvec[i])-exp(s01vec[k1]*othetavec[k1]));
    }
    //Rcpp::Rcout << excess << std::endl; // !!==
  }
  
  //Rcpp::Rcout << "s01vec" << std::endl; // !!==
  //Rcpp::Rcout << s01vec << std::endl; // **!!==
  //NumericVector excess(n);
  //Rcpp::Rcout << std::numeric_limits::epsilon( ) << std::endl;
  
  return clambdavec;
}


//*************************************************************************
//' Hazard and Integrated Hazard rate functions - LCV
//' 
//' @param tvec Locations at which to evaluate the function
//' @param lambda0 Offset to scale the hazard rate
//' @param w0 Offset to be added to the slope of the log hazard rate
//' @param thetavec Locations
//' @param wvec Weights
//' @param epsilon Size of value close to zero
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_lcv_c(NumericVector tvec,
                              double lambda0,
                              double w0,
                              NumericVector thetavec, 
                              NumericVector wvec,
                              double epsilon  // needs 100*.Machine$double.neg.eps
) {
  int n = tvec.size();
  int kmax = thetavec.size();
  int kmaxp2 = kmax+2;
  NumericMatrix haz_chz_mat(n,2);
  IntegerVector odx(kmax);
  NumericVector othetavec(kmaxp2);
  NumericVector owvec(kmaxp2);
  NumericVector s01vec(kmaxp2); 
  NumericVector s2vec(kmaxp2);
  NumericVector ccvec(kmaxp2);
  double cs;
  NumericVector ssvec(kmaxp2);
  int i,k,k1;
  
  odx = orderfunc_c(thetavec);
  othetavec[0] = 0;
  owvec[0] = 0;
  for(k=0; k<kmax; k++) {
    othetavec[k+1] = thetavec[odx[k]-1];
    owvec[k+1] = wvec[odx[k]-1];
  }
  othetavec[kmaxp2-1] = 1.1*othetavec[kmaxp2-2];
  owvec[kmaxp2-1] = 0;
  
  s01vec[0] = w0;
  s2vec[0] = 0;
  for(k=1; k<kmaxp2; k++) {
    s01vec[k] = s01vec[k-1] + owvec[k];   // w0+C
    s2vec[k] = s2vec[k-1] + owvec[k]*othetavec[k];  // D
  }
  
  ssvec[0] = 0;
  for(k=0; k<kmaxp2-1; k++) {
    ccvec[k] = lambda0*exp(-s2vec[k]);
    if(s01vec[k]==0) {
      cs = ccvec[k]*(othetavec[k+1]-othetavec[k]);
    } else {
      cs = (ccvec[k]/s01vec[k])*(exp(s01vec[k]*othetavec[k+1])-exp(s01vec[k]*othetavec[k]));
    }
    ssvec[k+1] = ssvec[k] + cs;
  }
  ccvec[kmaxp2-1] = ccvec[kmaxp2-2];
  
  
  for(i=0; i<n; i++) {
    k1 = 0;
    while( (k1<kmaxp2-1) && (othetavec[k1+1]<=tvec[i]) ) {   // try < rather than <=?
      k1++;
    }
    haz_chz_mat(i,0) = lambda0*exp(s01vec[k1]*tvec[i]-s2vec[k1]);
    haz_chz_mat(i,1) = ssvec[k1];
    if(std::abs(s01vec[k1])<epsilon) {
      haz_chz_mat(i,1) += ccvec[k1]*(tvec[i]-othetavec[k1]);
    } else {
      haz_chz_mat(i,1) += (ccvec[k1]/s01vec[k1])*(exp(s01vec[k1]*tvec[i])-exp(s01vec[k1]*othetavec[k1]));
    }
  }
  
  return haz_chz_mat;
}


//**********************************************************************
//* MEW - Modified Exponential Weibull
//**********************************************************************
//' Hazard rate function - MEW
//' 
//' @param tvec Locations at which to evaluate the function
//' @param alpha alpha
//' @param beta beta
//' @param nu nu
//' @param mu mu 
//' 
//' @description Hazard rate function for MEW hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector hazf_mew_c(NumericVector tvec,
                         double alpha, double beta,
                         double mu, double nu
) {
  int n = tvec.size();
  NumericVector lambdavec(n);
  double z, zd;
  int i;
  
  for(i=0; i<n; i++) {
    z = exp(pow(mu*tvec[i],beta))-1;
    zd = (1+z)*mu*beta*pow(mu*tvec[i],beta-1);
    lambdavec[i] = zd*(nu+alpha*pow(z,alpha-1));
  }
  
  return lambdavec;
}

//**********************************************************************
//' Integrated Hazard rate function - MEW
//' 
//' @param tvec Locations at which to evaluate the function
//' @param alpha alpha
//' @param beta beta
//' @param nu nu
//' @param mu mu 
//' 
//' @description Integrated hazard rate function for MEW hazard
//' 
//' @export
// [[Rcpp::export]]
NumericVector chzf_mew_c(NumericVector tvec,
                         double alpha, double beta,
                         double mu, double nu
) {
  int n = tvec.size();
  NumericVector clambdavec(n);
  double z;
  int i;
  
  for(i=0; i<n; i++) {
    z = exp(pow(mu*tvec[i],beta))-1;
    clambdavec[i] = nu*z + pow(z,alpha);
  }
  
  return clambdavec;
}

//*************************************************************************
//' Hazard and Integrated Hazard rate functions - MEW
//' 
//' @param tvec Locations at which to evaluate the function
//' @param alpha alpha
//' @param beta beta
//' @param nu nu
//' @param mu mu 
//' 
//' @description Hazard rate and integrated hazard rate functions generated by 
//' a set of discrete locations and weights and integrated
//' 
//' @export
// [[Rcpp::export]]
NumericMatrix hazf_chzf_mew_c(NumericVector tvec,
                              double alpha, double beta,
                              double mu, double nu) {
 int n = tvec.size();
 NumericMatrix haz_chz_mat(n,2);
 double z, zd;
 int i;
 
 for(i=0; i<n; i++) {
   z = exp(pow(mu*tvec[i],beta))-1;
   zd = (1+z)*mu*beta*pow(mu*tvec[i],beta-1);
   haz_chz_mat(i,0) = zd*(nu+alpha*pow(z,alpha-1));
   haz_chz_mat(i,1) = nu*z + pow(z,alpha);
 }

 return haz_chz_mat;
}

//**********************************************************************
//' Log prior - MEW
//' 
//' 
//' @param alpha alpha
//' @param beta beta
//' @param mu mu
//' @param nu nu
//' @param a1 a1 Prior for alpha
//' @param a2 a2 Prior for alpha
//' @param b1 b1 Prior for beta
//' @param b2 b2 Prior for beta
//' @param s1 s1 Prior for mu
//' @param s2 s2 Prior for mu
//' @param t1 t1 Prior for nu
//' @param t2 t2 Prior for nu
//' 
//' @description log(prior) for the MEW model - in vector form
//' 
//' @export
// [[Rcpp::export]]
NumericVector logprior_mew_c(double alpha,
                             double beta,
                             double mu,
                             double nu,
                             double a1, double a2,
                             double b1, double b2,
                             double s1, double s2,
                             double t1, double t2) {
 
 NumericVector lpriorvec(4);
 
 // alpha
 lpriorvec[0] = R::dgamma(alpha, a1, 1./a2, true);
 // beta
 lpriorvec[1] = R::dgamma(beta, b1, 1./b2, true);
 // mu
 lpriorvec[2] = R::dgamma(mu, s1, 1./s2, true);
 // nu
 lpriorvec[3] = R::dgamma(nu, t1, 1./t2, true);
 
 return lpriorvec;
}   

 